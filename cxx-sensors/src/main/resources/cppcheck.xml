<?xml version="1.0" encoding="us-ascii"?>
<rules>
  <rule>
    <key>CustomRuleTemplate</key>
    <cardinality>MULTIPLE</cardinality>
    <name><![CDATA[Template for custom Custom rules]]></name>
    <description>
      <![CDATA[
<p>
Follow these steps to make your custom Custom rules available in SonarQube:
</p>

<ol>
  <ol>
    <li>Create a new rule in SonarQube by "copying" this rule template and specify the <code>CheckId</code> of your custom rule, a title, a description, and a default severity.</li>
    <li>Enable the newly created rule in your quality profile</li>
  </ol>
  <li>Relaunch an analysis on your projects, et voila, your custom rules are executed!</li>
</ol>
]]>
    </description>
    <severity>MAJOR</severity>
  </rule>
  <rule>
    <key>AssignmentAddressToInteger</key>
    <name>Assigning a pointer to an integer is not portable</name>
    <description>
      <![CDATA[
Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t).
]]>
    </description>
    <tag>bug</tag>
    <internalKey>AssignmentAddressToInteger</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>AssignmentIntegerToAddress</key>
    <name>Assigning an integer to a pointer is not portable</name>
    <description>
      <![CDATA[
Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t).
]]>
    </description>
    <tag>bug</tag>
    <internalKey>AssignmentIntegerToAddress</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>CastAddressToIntegerAtReturn</key>
    <name>Returning an address value in a function with integer return type is not portable</name>
    <description>
      <![CDATA[
Returning an address value in a function with integer (int/long/etc) return type is not portable across different platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in 64-bit Windows and Linux they are of different width. In worst case you end up casting 64-bit address down to 32-bit integer. The safe way is to always return an integer.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>CastAddressToIntegerAtReturn</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>CastIntegerToAddressAtReturn</key>
    <name>Returning an integer in a function with pointer return type is not portable</name>
    <description>
      <![CDATA[
Returning an integer (int/long/etc) in a function with pointer return type is not portable across different platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in 64-bit Windows and Linux they are of different width. In worst case you end up casting 64-bit integer down to 32-bit pointer. The safe way is to always return a pointer.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>CastIntegerToAddressAtReturn</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>ConfigurationNotChecked</key>
    <name>Skipping configuration 'X' since the value of 'X' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly</name>
    <description>
      <![CDATA[
Skipping configuration 'X' since the value of 'X' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly.
]]>
    </description>
    <internalKey>ConfigurationNotChecked</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>IOWithoutPositioning</key>
    <name>Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour</name>
    <description>
      <![CDATA[
Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>IOWithoutPositioning</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>StlMissingComparison</key>
    <name>Missing bounds check for extra iterator increment in loop</name>
    <description>
      <![CDATA[
The iterator incrementing is suspicious - it is incremented at line  and then at line . The loop might unintentionally skip an element in the container. There is no comparison between these increments to prevent that the iterator is incremented beyond the end.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>StlMissingComparison</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>argumentSize</key>
    <name>The array 'array' is too small, the function 'function' expects a bigger one</name>
    <description>
      <![CDATA[
The array 'array' is too small, the function 'function' expects a bigger one.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>argumentSize</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>arithOperationsOnVoidPointer</key>
    <name>'varname' is of type 'vartype'. When using void pointers in calculations, the behaviour is undefined</name>
    <description>
      <![CDATA[
'varname' is of type 'vartype'. When using void pointers in calculations, the behaviour is undefined. Arithmetic operations on 'void *' is a GNU C extension, which defines the 'sizeof(void)' to be 1.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>arithOperationsOnVoidPointer</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>arrayIndexOutOfBounds</key>
    <name>Array 'array[2]' accessed at index 2, which is out of bounds</name>
    <description>
      <![CDATA[
Array 'array[2]' accessed at index 2, which is out of bounds.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>arrayIndexOutOfBounds</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>arrayIndexOutOfBoundsCond</key>
    <name>Array 'x[10]' accessed at index 20, which is out of bounds. Otherwise condition 'y==20' is redundant</name>
    <description>
      <![CDATA[
Array 'x[10]' accessed at index 20, which is out of bounds. Otherwise condition 'y==20' is redundant.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>arrayIndexOutOfBoundsCond</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>arrayIndexThenCheck</key>
    <name>Array index 'index' is used before limits check</name>
    <description>
      <![CDATA[
Defensive programming: The variable 'index' is used as an array index before it is checked that is within limits. This can mean that the array might be accessed out of bounds. Reorder conditions such as '(a[i] &amp;&amp; i < 10)' to '(i < 10 &amp;&amp; a[i])'. That way the array will not be accessed if the index is out of limits.
]]>
    </description>
    <internalKey>arrayIndexThenCheck</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>assertWithSideEffect</key>
    <name>Assert statement calls a function which may have desired side effects: 'function'</name>
    <description>
      <![CDATA[
Non-pure function: 'function' is called inside assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>assertWithSideEffect</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>assignBoolToPointer</key>
    <name>Boolean value assigned to pointer</name>
    <description>
      <![CDATA[
Boolean value assigned to pointer.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>assignBoolToPointer</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>assignIfError</key>
    <name>Mismatching assignment and comparison, comparison '' is always false</name>
    <description>
      <![CDATA[
Mismatching assignment and comparison, comparison '' is always false.
]]>
    </description>
    <internalKey>assignIfError</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>assignmentInAssert</key>
    <name>Assert statement modifies 'var'</name>
    <description>
      <![CDATA[
Variable 'var' is modified insert assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>assignmentInAssert</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>autoVariables</key>
    <name>Address of local auto-variable assigned to a function parameter</name>
    <description>
      <![CDATA[
Dangerous assignment - the function parameter is assigned the address of a local auto-variable. Local auto-variables are reserved from the stack which is freed when the function ends. So the pointer to a local variable is invalid after the function ends.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>autoVariables</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>autovarInvalidDeallocation</key>
    <name>Deallocation of an auto-variable results in undefined behaviour</name>
    <description>
      <![CDATA[
The deallocation of an auto-variable results in undefined behaviour. You should only free memory that has been allocated dynamically.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>autovarInvalidDeallocation</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>bitwiseOnBoolean</key>
    <name>Boolean variable 'varname' is used in bitwise operation. Did you mean '&amp;&amp;'?</name>
    <description>
      <![CDATA[
Boolean variable 'varname' is used in bitwise operation. Did you mean '&amp;&amp;'?
]]>
    </description>
    <internalKey>bitwiseOnBoolean</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>boostForeachError</key>
    <name>BOOST_FOREACH caches the end() iterator. It's undefined behavior if you modify the container inside</name>
    <description>
      <![CDATA[
BOOST_FOREACH caches the end() iterator. It's undefined behavior if you modify the container inside.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>boostForeachError</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>bufferAccessOutOfBounds</key>
    <name>Buffer is accessed out of bounds: buffer</name>
    <description>
      <![CDATA[
Buffer is accessed out of bounds: buffer
]]>
    </description>
    <tag>bug</tag>
    <internalKey>bufferAccessOutOfBounds</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>bufferNotZeroTerminated</key>
    <name>The buffer 'buffer' is not null-terminated after the call to strncpy()</name>
    <description>
      <![CDATA[
The buffer 'buffer' is not null-terminated after the call to strncpy(). This will cause bugs later in the code if the code assumes the buffer is null-terminated.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>bufferNotZeroTerminated</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>catchExceptionByValue</key>
    <name>Exception should be caught by reference</name>
    <description>
      <![CDATA[
The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++.
]]>
    </description>
    <internalKey>catchExceptionByValue</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>charArrayIndex</key>
    <name>Signed 'char' type used as array index</name>
    <description>
      <![CDATA[
Signed 'char' type used as array index. If the value can be greater than 127 there will be a buffer underflow because of sign extension.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>charArrayIndex</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>charBitOp</key>
    <name>When using 'char' variables in bit operations, sign extension can generate unexpected results</name>
    <description>
      <![CDATA[
When using 'char' variables in bit operations, sign extension can generate unexpected results. For example:\012    char c = 0x80;\012    int i = 0 | c;\012    if (i &amp; 0x8000)\012        printf("not expected");\012The "not expected" will be printed on the screen.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>charBitOp</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>charLiteralWithCharPtrCompare</key>
    <name>Char literal compared with pointer 'foo'. Did you intend to dereference it?</name>
    <description>
      <![CDATA[
Char literal compared with pointer 'foo'. Did you intend to dereference it?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>charLiteralWithCharPtrCompare</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>checkCastIntToCharAndBack</key>
    <name>Storing func_name() return value in char variable and then comparing with EOF</name>
    <description>
      <![CDATA[
When saving func_name() return value in char variable there is loss of precision.  When func_name() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop "while (EOF != (c = func_name());" loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>checkCastIntToCharAndBack</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>clarifyCalculation</key>
    <name>Clarify calculation precedence for '+' and '?'</name>
    <description>
      <![CDATA[
Suspicious calculation. Please use parentheses to clarify the code. The code ''a+b?c:d'' should be written as either ''(a+b)?c:d'' or ''a+(b?c:d)''.
]]>
    </description>
    <internalKey>clarifyCalculation</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>clarifyCondition</key>
    <name>Suspicious condition (assignment + comparison); Clarify expression with parentheses</name>
    <description>
      <![CDATA[
Suspicious condition (assignment + comparison); Clarify expression with parentheses.
]]>
    </description>
    <internalKey>clarifyCondition</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>clarifyStatement</key>
    <name>Ineffective statement similar to '*A++;'. Did you intend to write '(*A)++;'?</name>
    <description>
      <![CDATA[
A statement like '*A++;' might not do what you intended. Postfix 'operator++' is executed before 'operator*'. Thus, the dereference is meaningless. Did you intend to write '(*A)++;'?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>clarifyStatement</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>commaSeparatedReturn</key>
    <name>Comma is used in return statement. The comma can easily be misread as a ';'</name>
    <description>
      <![CDATA[
Comma is used in return statement. When comma is used in a return statement it can easily be misread as a semicolon. For example in the code below the value of 'b' is returned if the condition is true, but it is easy to think that 'a+1' is returned:\012    if (x)\012        return a + 1,\012    b++;\012However it can be useful to use comma in macros. Cppcheck does not warn when such a macro is then used in a return statement, it is less likely such code is misunderstood.
]]>
    </description>
    <internalKey>commaSeparatedReturn</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>compareBoolExpressionWithInt</key>
    <name>Comparison of a boolean expression with an integer other than 0 or 1</name>
    <description>
      <![CDATA[
Comparison of a boolean expression with an integer other than 0 or 1.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>compareBoolExpressionWithInt</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>comparisonError</key>
    <name>Expression '(X &amp; 0x6) == 0x1' is always false</name>
    <description>
      <![CDATA[
The expression '(X &amp; 0x6) == 0x1' is always false. Check carefully constants and operators used, these errors might be hard to spot sometimes. In case of complex expression it might help to split it to separate expressions.
]]>
    </description>
    <internalKey>comparisonError</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>comparisonFunctionIsAlwaysTrueOrFalse</key>
    <name>Comparison of two identical variables with isless(varName,varName) evaluates always to false</name>
    <description>
      <![CDATA[
The function isless is designed to compare two variables. Calling this function with one variable (varName) for both parameters leads to a statement which is always false.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>comparisonFunctionIsAlwaysTrueOrFalse</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>comparisonOfBoolWithBoolError</key>
    <name>Comparison of a variable having boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
      <![CDATA[
The variable 'var_name' is of type 'bool' and comparing 'bool' value using relational (&lt;, &gt;, &lt;= or &gt;=) operator could cause unexpected results.
]]>
    </description>
    <internalKey>comparisonOfBoolWithBoolError</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>comparisonOfBoolWithInt</key>
    <name>Comparison of a boolean with an integer that is neither 1 nor 0</name>
    <description>
      <![CDATA[
The expression 'varname' is of type 'bool' and it is compared against an integer value that is neither 1 nor 0.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>comparisonOfBoolWithInt</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>comparisonOfFuncReturningBoolError</key>
    <name>Comparison of a function returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
      <![CDATA[
The return type of function 'func_name' is 'bool' and result is of type 'bool'. Comparing 'bool' value using relational (&lt;, &gt;, &lt;= or &gt;=) operator could cause unexpected results.
]]>
    </description>
    <internalKey>comparisonOfFuncReturningBoolError</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>comparisonOfTwoFuncsReturningBoolError</key>
    <name>Comparison of two functions returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
      <![CDATA[
The return type of function 'func_name1' and function 'func_name2' is 'bool' and result is of type 'bool'. Comparing 'bool' value using relational (&lt;, &gt;, &lt;= or &gt;=) operator could cause unexpected results.
]]>
    </description>
    <internalKey>comparisonOfTwoFuncsReturningBoolError</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>constStatement</key>
    <name>Redundant code: Found a statement that begins with type constant</name>
    <description>
      <![CDATA[
Redundant code: Found a statement that begins with type constant.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>constStatement</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>copyCtorPointerCopying</key>
    <name>Value of pointer 'var', which points to allocated memory, is copied in copy constructor instead of allocating new memory</name>
    <description>
      <![CDATA[
Value of pointer 'var', which points to allocated memory, is copied in copy constructor instead of allocating new memory.
]]>
    </description>
    <internalKey>copyCtorPointerCopying</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>coutCerrMisusage</key>
    <name>Invalid usage of output stream: '&lt;&lt; std::cout'</name>
    <description>
      <![CDATA[
Invalid usage of output stream: '&lt;&lt; std::cout'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>coutCerrMisusage</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>cstyleCast</key>
    <name>C-style pointer casting</name>
    <description>
      <![CDATA[
C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts.
]]>
    </description>
    <internalKey>cstyleCast</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>deadpointer</key>
    <name>Dead pointer usage. Pointer 'pointer' is dead if it has been assigned '&amp;x' at line 0</name>
    <description>
      <![CDATA[
Dead pointer usage. Pointer 'pointer' is dead if it has been assigned '&amp;x' at line 0.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>deadpointer</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>deallocDealloc</key>
    <name>Deallocating a deallocated pointer: varname</name>
    <description>
      <![CDATA[
Deallocating a deallocated pointer: varname
]]>
    </description>
    <tag>bug</tag>
    <internalKey>deallocDealloc</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>deallocret</key>
    <name>Returning/dereferencing 'p' after it is deallocated / released</name>
    <description>
      <![CDATA[
Returning/dereferencing 'p' after it is deallocated / released
]]>
    </description>
    <tag>bug</tag>
    <internalKey>deallocret</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>deallocuse</key>
    <name>Dereferencing 'varname' after it is deallocated / released</name>
    <description>
      <![CDATA[
Dereferencing 'varname' after it is deallocated / released
]]>
    </description>
    <tag>bug</tag>
    <internalKey>deallocuse</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>derefInvalidIterator</key>
    <name>Possible dereference of an invalid iterator: i</name>
    <description>
      <![CDATA[
Make sure to check that the iterator is valid before dereferencing it - not after.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>derefInvalidIterator</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>doubleFree</key>
    <name>Memory pointed to by 'varname' is freed twice</name>
    <description>
      <![CDATA[
Memory pointed to by 'varname' is freed twice.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>doubleFree</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>duplInheritedMember</key>
    <name>The class 'class' defines member variable with name 'variable' also defined in its parent class 'class'</name>
    <description>
      <![CDATA[
The class 'class' defines member variable with name 'variable' also defined in its parent class 'class'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>duplInheritedMember</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>duplicateBranch</key>
    <name>Found duplicate branches for 'if' and 'else'</name>
    <description>
      <![CDATA[
Finding the same code in an 'if' and related 'else' branch is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct.
]]>
    </description>
    <internalKey>duplicateBranch</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>duplicateBreak</key>
    <name>Consecutive return, break, continue, goto or throw statements are unnecessary</name>
    <description>
      <![CDATA[
Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed.
]]>
    </description>
    <internalKey>duplicateBreak</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>duplicateExpression</key>
    <name>Same expression on both sides of '&amp;&amp;'</name>
    <description>
      <![CDATA[
Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct.
]]>
    </description>
    <internalKey>duplicateExpression</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>eraseDereference</key>
    <name>Invalid iterator 'iter' used</name>
    <description>
      <![CDATA[
The iterator 'iter' is invalid before being assigned. Dereferencing or comparing it with another iterator is invalid operation.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>eraseDereference</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>exceptDeallocThrow</key>
    <name>Exception thrown in invalid state, 'p' points at deallocated memory</name>
    <description>
      <![CDATA[
Exception thrown in invalid state, 'p' points at deallocated memory.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>exceptDeallocThrow</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>exceptRethrowCopy</key>
    <name>Throwing a copy of the caught exception instead of rethrowing the original exception</name>
    <description>
      <![CDATA[
Rethrowing an exception with 'throw varname;' creates an unnecessary copy of 'varname'. To rethrow the caught exception without unnecessary copying or slicing, use a bare 'throw;'.
]]>
    </description>
    <internalKey>exceptRethrowCopy</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>exceptThrowInDestructor</key>
    <name>Class Class is not safe, destructor throws exception</name>
    <description>
      <![CDATA[
The class Class is not safe because its destructor throws an exception. If Class is used and an exception is thrown that is caught in an outer scope the program will terminate.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>exceptThrowInDestructor</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>fflushOnInputStream</key>
    <name>fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems</name>
    <description>
      <![CDATA[
fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>fflushOnInputStream</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>functionConst</key>
    <name>Technically the member function 'class::function' can be const</name>
    <description>
      <![CDATA[
The member function 'class::function' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state?
]]>
    </description>
    <internalKey>functionConst</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>functionStatic</key>
    <name>Technically the member function 'class::function' can be static</name>
    <description>
      <![CDATA[
The member function 'class::function' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>functionStatic</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>ignoredReturnValue</key>
    <name>Return value of function malloc() is not used</name>
    <description>
      <![CDATA[
Return value of function malloc() is not used.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>ignoredReturnValue</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>incompleteArrayFill</key>
    <name>Array 'buffer' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*buffer)'?</name>
    <description>
      <![CDATA[
The array 'buffer' is filled incompletely. The function 'memset()' needs the size given in bytes, but an element of the given array is larger than one byte. Did you forget to multiply the size with 'sizeof(*buffer)'?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>incompleteArrayFill</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>incorrectLogicOperator</key>
    <name>Logical disjunction always evaluates to true: foo &gt; 3 &amp;&amp; foo &lt; 4</name>
    <description>
      <![CDATA[
Logical disjunction always evaluates to true: foo &gt; 3 &amp;&amp; foo &lt; 4. Are these conditions necessary? Did you intend to use &amp;&amp; instead? Are the numbers correct? Are you comparing the correct variables?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>incorrectLogicOperator</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>incorrectStringBooleanError</key>
    <name>Conversion of string literal "Hello World" to bool always evaluates to true</name>
    <description>
      <![CDATA[
Conversion of string literal "Hello World" to bool always evaluates to true.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>incorrectStringBooleanError</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>incorrectStringCompare</key>
    <name>String literal "Hello World" doesn't match length argument for substr()</name>
    <description>
      <![CDATA[
String literal "Hello World" doesn't match length argument for substr().
]]>
    </description>
    <tag>bug</tag>
    <internalKey>incorrectStringCompare</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>incrementboolean</key>
    <name>Incrementing a variable of type 'bool' with postfix operator++ is deprecated by the C++ Standard. You should assign it the value 'true' instead</name>
    <description>
      <![CDATA[
The operand of a postfix increment operator may be of type bool but it is deprecated by C++ Standard (Annex D-1) and the operand is always set to true. You should assign it the value 'true' instead.
]]>
    </description>
    <internalKey>incrementboolean</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>initializerList</key>
    <name>Member variable 'class::variable' is in the wrong place in the initializer list</name>
    <description>
      <![CDATA[
Member variable 'class::variable' is in the wrong place in the initializer list. Members are initialized in the order they are declared, not in the order they are in the initializer list.  Keeping the initializer list in the same order that the members were declared prevents order dependent initialization errors.
]]>
    </description>
    <internalKey>initializerList</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>insecureCmdLineArgs</key>
    <name>Buffer overrun possible for long command line arguments</name>
    <description>
      <![CDATA[
Buffer overrun possible for long command line arguments.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>insecureCmdLineArgs</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>integerOverflow</key>
    <name>Signed integer overflow for expression ''</name>
    <description>
      <![CDATA[
Signed integer overflow for expression ''
]]>
    </description>
    <tag>bug</tag>
    <internalKey>integerOverflow</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidFunctionArg</key>
    <name>Invalid func_name() argument nr 1</name>
    <description>
      <![CDATA[
Invalid func_name() argument nr 1
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidFunctionArg</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidFunctionArgBool</key>
    <name>Invalid func_name() argument nr 1. A non-boolean value is required</name>
    <description>
      <![CDATA[
Invalid func_name() argument nr 1. A non-boolean value is required.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidFunctionArgBool</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidIterator1</key>
    <name>Invalid iterator: iterator</name>
    <description>
      <![CDATA[
Invalid iterator: iterator
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidIterator1</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidIterator2</key>
    <name>After push_back|push_front|insert(), the iterator 'iterator' may be invalid</name>
    <description>
      <![CDATA[
After push_back|push_front|insert(), the iterator 'iterator' may be invalid.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidIterator2</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidLengthModifierError</key>
    <name>'I' in format string (no. 1) is a length modifier and cannot be used without a conversion specifier</name>
    <description>
      <![CDATA[
'I' in format string (no. 1) is a length modifier and cannot be used without a conversion specifier.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidLengthModifierError</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPointer</key>
    <name>Invalid pointer 'pointer' after push_back()</name>
    <description>
      <![CDATA[
Invalid pointer 'pointer' after push_back().
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPointer</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPointerCast</key>
    <name>Casting between float* and double* which have an incompatible binary data representation</name>
    <description>
      <![CDATA[
Casting between float* and double* which have an incompatible binary data representation.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPointerCast</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPrintfArgType_float</key>
    <name>%f in format string (no. 1) requires 'double' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%f in format string (no. 1) requires 'double' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPrintfArgType_float</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPrintfArgType_int</key>
    <name>%X in format string (no. 1) requires 'unsigned int' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%X in format string (no. 1) requires 'unsigned int' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPrintfArgType_int</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPrintfArgType_n</key>
    <name>%n in format string (no. 1) requires 'int *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%n in format string (no. 1) requires 'int *' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPrintfArgType_n</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPrintfArgType_p</key>
    <name>%p in format string (no. 1) requires an address but the argument type is Unknown</name>
    <description>
      <![CDATA[
%p in format string (no. 1) requires an address but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPrintfArgType_p</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPrintfArgType_s</key>
    <name>%s in format string (no. 1) requires 'char *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%s in format string (no. 1) requires 'char *' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPrintfArgType_s</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPrintfArgType_sint</key>
    <name>%i in format string (no. 1) requires 'int' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%i in format string (no. 1) requires 'int' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPrintfArgType_sint</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidPrintfArgType_uint</key>
    <name>%u in format string (no. 1) requires 'unsigned int' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%u in format string (no. 1) requires 'unsigned int' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidPrintfArgType_uint</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidScanfArgType_float</key>
    <name>%f in format string (no. 1) requires 'float *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%f in format string (no. 1) requires 'float *' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidScanfArgType_float</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidScanfArgType_int</key>
    <name>%d in format string (no. 1) requires 'int *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%d in format string (no. 1) requires 'int *' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidScanfArgType_int</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidScanfArgType_s</key>
    <name>%s in format string (no. 1) requires a 'char *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%s in format string (no. 1) requires a 'char *' but the argument type is Unknown.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidScanfArgType_s</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidScanfFormatWidth</key>
    <name>Width 5 given in format string (no. 10) is larger than destination buffer '[0]', use %-1s to prevent overflowing it</name>
    <description>
      <![CDATA[
Width 5 given in format string (no. 10) is larger than destination buffer '[0]', use %-1s to prevent overflowing it.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidScanfFormatWidth</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidscanf</key>
    <name>scanf without field width limits can crash with huge input data</name>
    <description>
      <![CDATA[
scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:\012    %s => %20s\012\012Sample program that can crash:\012\012#include &lt;stdio.h&gt;\012int main()\012{\012    char c[5];\012    scanf("%s", c);\012    return 0;\012}\012\012Typing in 5 or more characters may make the program crash. The correct usage here is 'scanf("%4s", c);', as the maximum field width does not include the terminating null byte.\012Source: http://linux.die.net/man/3/scanf\012Source: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidscanf</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidscanf_libc</key>
    <name>scanf without field width limits can crash with huge input data on some versions of libc</name>
    <description>
      <![CDATA[
scanf without field width limits can crash with huge input data on libc versions older than 2.13-25. Add a field width specifier to fix this problem:\012    %i => %3i\012\012Sample program that can crash:\012\012#include &lt;stdio.h&gt;\012int main()\012{\012    int a;\012    scanf("%i", &amp;a);\012    return 0;\012}\012\012To make it crash:\012perl -e 'print "5"x2100000' | ./a.out
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidscanf_libc</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>iterators</key>
    <name>Same iterator is used with different containers 'container1' and 'container2'</name>
    <description>
      <![CDATA[
Same iterator is used with different containers 'container1' and 'container2'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>iterators</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>leakNoVarFunctionCall</key>
    <name>Allocation with funcName, funcName doesn't release it</name>
    <description>
      <![CDATA[
Allocation with funcName, funcName doesn't release it.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>leakNoVarFunctionCall</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>leakReturnValNotUsed</key>
    <name>Return value of allocation function funcName is not stored</name>
    <description>
      <![CDATA[
Return value of allocation function funcName is not stored.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>leakReturnValNotUsed</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>literalWithCharPtrCompare</key>
    <name>String literal compared with variable 'foo'. Did you intend to use strcmp() instead?</name>
    <description>
      <![CDATA[
String literal compared with variable 'foo'. Did you intend to use strcmp() instead?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>literalWithCharPtrCompare</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>mallocOnClassError</key>
    <name>Memory for class instance allocated with malloc(), but class contains a std::string</name>
    <description>
      <![CDATA[
Memory for class instance allocated with malloc(), but class a std::string. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>mallocOnClassError</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>mallocOnClassWarning</key>
    <name>Memory for class instance allocated with malloc(), but class provides constructors</name>
    <description>
      <![CDATA[
Memory for class instance allocated with malloc(), but class provides constructors. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>mallocOnClassWarning</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>memleak</key>
    <name>Memory leak: varname</name>
    <description>
      <![CDATA[
Memory leak: varname
]]>
    </description>
    <tag>bug</tag>
    <internalKey>memleak</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>memleakOnRealloc</key>
    <name>Common realloc mistake: 'varname' nulled but not freed upon failure</name>
    <description>
      <![CDATA[
Common realloc mistake: 'varname' nulled but not freed upon failure
]]>
    </description>
    <tag>bug</tag>
    <internalKey>memleakOnRealloc</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>memsetClass</key>
    <name>Using 'memfunc' on class that contains a classname</name>
    <description>
      <![CDATA[
Using 'memfunc' on class that contains a classname is unsafe, because constructor, destructor and copy operator calls are omitted. These are necessary for this non-POD type to ensure that a valid object is created.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>memsetClass</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>memsetClassFloat</key>
    <name>Using memset() on class which contains a floating point number</name>
    <description>
      <![CDATA[
Using memset() on class which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined.
Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>memsetClassFloat</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>memsetClassReference</key>
    <name>Using 'memfunc' on class that contains a reference</name>
    <description>
      <![CDATA[
Using 'memfunc' on class that contains a reference.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>memsetClassReference</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>memsetFloat</key>
    <name>The 2nd memset() argument 'varname' is a float, its representation is implementation defined</name>
    <description>
      <![CDATA[
The 2nd memset() argument 'varname' is a float, its representation is implementation defined. memset() is used to set each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>memsetFloat</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>memsetValueOutOfRange</key>
    <name>The 2nd memset() argument 'varname' doesn't fit into an 'unsigned char'</name>
    <description>
      <![CDATA[
The 2nd memset() argument 'varname' doesn't fit into an 'unsigned char'. The 2nd parameter is passed as an 'int', but the function fills the block of memory using the 'unsigned char' conversion of this value.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>memsetValueOutOfRange</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>memsetZeroBytes</key>
    <name>memset() called to fill 0 bytes of 'varname'</name>
    <description>
      <![CDATA[
memset() called to fill 0 bytes of 'varname'. The second and third arguments might be inverted. The function memset ( void * ptr, int value, size_t num ) sets the first num bytes of the block of memory pointed by ptr to the specified value.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>memsetZeroBytes</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>mismatchAllocDealloc</key>
    <name>Mismatching allocation and deallocation: varname</name>
    <description>
      <![CDATA[
Mismatching allocation and deallocation: varname
]]>
    </description>
    <tag>bug</tag>
    <internalKey>mismatchAllocDealloc</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>mismatchSize</key>
    <name>The allocated size sz is not a multiple of the underlying type's size</name>
    <description>
      <![CDATA[
The allocated size sz is not a multiple of the underlying type's size.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>mismatchSize</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>mismatchingBitAnd</key>
    <name>Mismatching bitmasks. Result is always 0 (X = Y &amp; 0xf0; Z = X &amp; 0x1; =&gt; Z=0)</name>
    <description>
      <![CDATA[
Mismatching bitmasks. Result is always 0 (X = Y &amp; 0xf0; Z = X &amp; 0x1; =&gt; Z=0).
]]>
    </description>
    <internalKey>mismatchingBitAnd</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>mismatchingContainers</key>
    <name>Iterators of different containers are used together</name>
    <description>
      <![CDATA[
Iterators of different containers are used together.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>mismatchingContainers</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>missingInclude</key>
    <name>Include file: "" not found</name>
    <description>
      <![CDATA[
Include file: "" not found.
]]>
    </description>
    <internalKey>missingInclude</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>missingIncludeSystem</key>
    <name>Include file: &lt;&gt; not found. Please note: Cppcheck does not need standard library headers to get proper results</name>
    <description>
      <![CDATA[
Include file: &lt;&gt; not found.
Please note: Cppcheck does not need standard library headers to get proper results.
]]>
    </description>
    <internalKey>missingIncludeSystem</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>moduloAlwaysTrueFalse</key>
    <name>Comparison of modulo result is predetermined, because it is always less than 1</name>
    <description>
      <![CDATA[
Comparison of modulo result is predetermined, because it is always less than 1.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>moduloAlwaysTrueFalse</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>multiCondition</key>
    <name>Expression is always false because 'else if' condition matches previous condition at line 1</name>
    <description>
      <![CDATA[
Expression is always false because 'else if' condition matches previous condition at line 1.
]]>
    </description>
    <internalKey>multiCondition</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nanInArithmeticExpression</key>
    <name>Using NaN/Inf in a computation</name>
    <description>
      <![CDATA[
Using NaN/Inf in a computation. Although nothing bad really happens, it is suspicious.
]]>
    </description>
    <internalKey>nanInArithmeticExpression</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>negativeIndex</key>
    <name>Array index -1 is out of bounds</name>
    <description>
      <![CDATA[
Array index -1 is out of bounds.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>negativeIndex</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>negativeMemoryAllocationSize</key>
    <name>Memory allocation size is negative</name>
    <description>
      <![CDATA[
Memory allocation size is negative.Negative allocation size has no specified behaviour.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>negativeMemoryAllocationSize</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>noConstructor</key>
    <name>The class 'classname' does not have a constructor</name>
    <description>
      <![CDATA[
The class 'classname' does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior.
]]>
    </description>
    <internalKey>noConstructor</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>noCopyConstructor</key>
    <name>'class class' does not have a copy constructor which is recommended since the class contains a pointer to allocated memory</name>
    <description>
      <![CDATA[
'class class' does not have a copy constructor which is recommended since the class contains a pointer to allocated memory.
]]>
    </description>
    <internalKey>noCopyConstructor</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionscrypt</key>
    <name>Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionscrypt</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsctermid</key>
    <name>Non reentrant function 'ctermid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ctermid_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'ctermid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ctermid_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsctermid</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsecvt</key>
    <name>Non reentrant function 'ecvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ecvt_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'ecvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ecvt_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsecvt</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfcvt</key>
    <name>Non reentrant function 'fcvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fcvt_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'fcvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fcvt_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsfcvt</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetgrent</key>
    <name>Non reentrant function 'fgetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetgrent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'fgetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetgrent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsfgetgrent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetpwent</key>
    <name>Non reentrant function 'fgetpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetpwent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'fgetpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetpwent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsfgetpwent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetspent</key>
    <name>Non reentrant function 'fgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetspent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'fgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetspent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsfgetspent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgcvt</key>
    <name>Non reentrant function 'gcvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gcvt_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gcvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gcvt_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgcvt</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrent</key>
    <name>Non reentrant function 'getgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetgrent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrgid</key>
    <name>Non reentrant function 'getgrgid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrgid_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getgrgid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrgid_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetgrgid</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrnam</key>
    <name>Non reentrant function 'getgrnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrnam_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getgrnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrnam_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetgrnam</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyaddr</key>
    <name>Non reentrant function 'gethostbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyaddr_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gethostbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyaddr_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgethostbyaddr</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyname</key>
    <name>Non reentrant function 'gethostbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gethostbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgethostbyname</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyname2</key>
    <name>Non reentrant function 'gethostbyname2' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname2_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gethostbyname2' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname2_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgethostbyname2</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostent</key>
    <name>Non reentrant function 'gethostent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gethostent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgethostent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetlogin</key>
    <name>Non reentrant function 'getlogin' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getlogin_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getlogin' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getlogin_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetlogin</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetbyaddr</key>
    <name>Non reentrant function 'getnetbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyaddr_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getnetbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyaddr_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetnetbyaddr</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetbyname</key>
    <name>Non reentrant function 'getnetbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getnetbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyname_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetnetbyname</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetgrent</key>
    <name>Non reentrant function 'getnetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetgrent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getnetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetgrent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetnetgrent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetprotobyname</key>
    <name>Non reentrant function 'getprotobyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getprotobyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobyname_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetprotobyname</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwent</key>
    <name>Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetpwent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwnam</key>
    <name>Non reentrant function 'getpwnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwnam_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getpwnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwnam_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetpwnam</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwuid</key>
    <name>Non reentrant function 'getpwuid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwuid_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getpwuid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwuid_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetpwuid</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcbyname</key>
    <name>Non reentrant function 'getrpcbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getrpcbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbyname_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetrpcbyname</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcbynumber</key>
    <name>Non reentrant function 'getrpcbynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbynumber_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getrpcbynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbynumber_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetrpcbynumber</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcent</key>
    <name>Non reentrant function 'getrpcent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getrpcent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetrpcent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservbyname</key>
    <name>Non reentrant function 'getservbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getservbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyname_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetservbyname</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservbyport</key>
    <name>Non reentrant function 'getservbyport' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyport_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getservbyport' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyport_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetservbyport</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservent</key>
    <name>Non reentrant function 'getservent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getservent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetservent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetspent</key>
    <name>Non reentrant function 'getspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspent_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetspent</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetspnam</key>
    <name>Non reentrant function 'getspnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspnam_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getspnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspnam_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgetspnam</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgmtime</key>
    <name>Non reentrant function 'gmtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gmtime_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gmtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gmtime_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsgmtime</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionslocaltime</key>
    <name>Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionslocaltime</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsreaddir</key>
    <name>Non reentrant function 'readdir' called. For threadsafe applications it is recommended to use the reentrant replacement function 'readdir_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'readdir' called. For threadsafe applications it is recommended to use the reentrant replacement function 'readdir_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsreaddir</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsstrtok</key>
    <name>Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsstrtok</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionstempnam</key>
    <name>Non reentrant function 'tempnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'tempnam_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'tempnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'tempnam_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionstempnam</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nonreentrantFunctionsttyname</key>
    <name>Non reentrant function 'ttyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ttyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'ttyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ttyname_r'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nonreentrantFunctionsttyname</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nullPointer</key>
    <name>Possible null pointer dereference: pointer</name>
    <description>
      <![CDATA[
Possible null pointer dereference: pointer
]]>
    </description>
    <tag>bug</tag>
    <internalKey>nullPointer</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsasctime_r</key>
    <name>Obsolete function 'asctime_r' called. It is recommended to use the function 'strftime' instead</name>
    <description>
      <![CDATA[
Obsolete function 'asctime_r' called. It is recommended to use the function 'strftime' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsasctime_r</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsbcmp</key>
    <name>Obsolete function 'bcmp' called. It is recommended to use the function 'memcmp' instead</name>
    <description>
      <![CDATA[
Obsolete function 'bcmp' called. It is recommended to use the function 'memcmp' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsbcmp</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsbcopy</key>
    <name>Obsolete function 'bcopy' called. It is recommended to use the 'memmove' or 'memcpy' function instead</name>
    <description>
      <![CDATA[
Obsolete function 'bcopy' called. It is recommended to use the 'memmove' or 'memcpy' function instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsbcopy</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsbsd_signal</key>
    <name>Obsolete function 'bsd_signal' called. It is recommended to use the function 'sigaction' instead</name>
    <description>
      <![CDATA[
Obsolete function 'bsd_signal' called. It is recommended to use the function 'sigaction' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsbsd_signal</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsbzero</key>
    <name>Obsolete function 'bzero' called. It is recommended to use the function 'memset' instead</name>
    <description>
      <![CDATA[
Obsolete function 'bzero' called. It is recommended to use the function 'memset' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsbzero</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsctime_r</key>
    <name>Obsolete function 'ctime_r' called. It is recommended to use the function 'strftime' instead</name>
    <description>
      <![CDATA[
Obsolete function 'ctime_r' called. It is recommended to use the function 'strftime' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsctime_r</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsecvt</key>
    <name>Obsolete function 'ecvt' called. It is recommended to use the function 'sprintf' instead</name>
    <description>
      <![CDATA[
Obsolete function 'ecvt' called. It is recommended to use the function 'sprintf' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsecvt</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsfcvt</key>
    <name>Obsolete function 'fcvt' called. It is recommended to use the function 'sprintf' instead</name>
    <description>
      <![CDATA[
Obsolete function 'fcvt' called. It is recommended to use the function 'sprintf' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsfcvt</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsftime</key>
    <name>Obsolete function 'ftime' called. It is recommended to use time(), gettimeofday() or clock_gettime() instead</name>
    <description>
      <![CDATA[
Obsolete function 'ftime' called. It is recommended to use time(), gettimeofday() or clock_gettime() instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsftime</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsgcvt</key>
    <name>Obsolete function 'gcvt' called. It is recommended to use the function 'sprintf' instead</name>
    <description>
      <![CDATA[
Obsolete function 'gcvt' called. It is recommended to use the function 'sprintf' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsgcvt</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsgetcontext</key>
    <name>Obsolete function 'getcontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
Obsolete function 'getcontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.
]]>
    </description>
    <internalKey>obsoleteFunctionsgetcontext</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsgethostbyaddr</key>
    <name>Obsolete function 'gethostbyaddr' called. It is recommended to use the function 'getnameinfo' instead</name>
    <description>
      <![CDATA[
Obsolete function 'gethostbyaddr' called. It is recommended to use the function 'getnameinfo' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsgethostbyaddr</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsgethostbyname</key>
    <name>Obsolete function 'gethostbyname' called. It is recommended to use the function 'getaddrinfo' instead</name>
    <description>
      <![CDATA[
Obsolete function 'gethostbyname' called. It is recommended to use the function 'getaddrinfo' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsgethostbyname</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsgetwd</key>
    <name>Obsolete function 'getwd' called. It is recommended to use the function 'getcwd' instead</name>
    <description>
      <![CDATA[
Obsolete function 'getwd' called. It is recommended to use the function 'getcwd' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsgetwd</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsindex</key>
    <name>Obsolete function 'index' called. It is recommended to use the function 'strchr' instead</name>
    <description>
      <![CDATA[
Obsolete function 'index' called. It is recommended to use the function 'strchr' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsindex</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsmakecontext</key>
    <name>Obsolete function 'makecontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
Obsolete function 'makecontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.
]]>
    </description>
    <internalKey>obsoleteFunctionsmakecontext</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionspthread_attr_getstackaddr</key>
    <name>Obsolete function 'pthread_attr_getstackaddr' called. It is recommended to use the function 'pthread_attr_getstack' instead</name>
    <description>
      <![CDATA[
Obsolete function 'pthread_attr_getstackaddr' called. It is recommended to use the function 'pthread_attr_getstack' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionspthread_attr_getstackaddr</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionspthread_attr_setstackaddr</key>
    <name>Obsolete function 'pthread_attr_setstackaddr' called. It is recommended to use the function 'pthread_attr_setstack' instead</name>
    <description>
      <![CDATA[
Obsolete function 'pthread_attr_setstackaddr' called. It is recommended to use the function 'pthread_attr_setstack' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionspthread_attr_setstackaddr</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsrand_r</key>
    <name>Obsolete function 'rand_r' called. It is recommended to use the function 'rand' instead</name>
    <description>
      <![CDATA[
Obsolete function 'rand_r' called. It is recommended to use the function 'rand' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsrand_r</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsrindex</key>
    <name>Obsolete function 'rindex' called. It is recommended to use the function 'strrchr' instead</name>
    <description>
      <![CDATA[
Obsolete function 'rindex' called. It is recommended to use the function 'strrchr' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsrindex</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsscalbln</key>
    <name>Obsolete function 'scalb' called. It is recommended to use 'scalbln', 'scalblnf' or 'scalblnl' instead</name>
    <description>
      <![CDATA[
Obsolete function 'scalb' called. It is recommended to use 'scalbln', 'scalblnf' or 'scalblnl' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsscalbln</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsswapcontext</key>
    <name>Obsolete function 'swapcontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
Obsolete function 'swapcontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.
]]>
    </description>
    <internalKey>obsoleteFunctionsswapcontext</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionstmpnam</key>
    <name>Obsolete function 'tmpnam' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
Obsolete function 'tmpnam' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionstmpnam</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionstmpnam_r</key>
    <name>Obsolete function 'tmpnam_r' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
Obsolete function 'tmpnam_r' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionstmpnam_r</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsualarm</key>
    <name>Obsolete function 'ualarm' called. It is recommended to use 'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime' or 'timer_settime' instead</name>
    <description>
      <![CDATA[
Obsolete function 'ualarm' called. It is recommended to use 'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime' or 'timer_settime' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsualarm</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsusleep</key>
    <name>Obsolete function 'usleep' called. It is recommended to use the 'nanosleep' or 'setitimer' function instead</name>
    <description>
      <![CDATA[
The obsolete function 'usleep' is called. POSIX.1-2001 declares usleep() function obsolete and POSIX.1-2008 removes it. It is recommended that new applications use the 'nanosleep' or 'setitimer' function.
]]>
    </description>
    <internalKey>obsoleteFunctionsusleep</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsutime</key>
    <name>Obsolete function 'utime' called. It is recommended to use the function 'utimensat' instead</name>
    <description>
      <![CDATA[
Obsolete function 'utime' called. It is recommended to use the function 'utimensat' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsutime</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsvfork</key>
    <name>Obsolete function 'vfork' called. It is recommended to use the function 'fork' instead</name>
    <description>
      <![CDATA[
Obsolete function 'vfork' called. It is recommended to use the function 'fork' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionsvfork</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionswcswcs</key>
    <name>Obsolete function 'wcswcs' called. It is recommended to use the function 'wcsstr' instead</name>
    <description>
      <![CDATA[
Obsolete function 'wcswcs' called. It is recommended to use the function 'wcsstr' instead.
]]>
    </description>
    <internalKey>obsoleteFunctionswcswcs</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>operatorEq</key>
    <name>'class::operator=' should return 'class &amp;'</name>
    <description>
      <![CDATA[
The class::operator= does not conform to standard C/C++ behaviour. To conform to standard C/C++ behaviour, return a reference to self (such as: 'class &amp;class::operator=(..) { .. return *this; }'. For safety reasons it might be better to not fix this message. If you think that safety is always more important than conformance then please ignore/suppress this message. For more details about this topic, see the book "Effective C++" by Scott Meyers.
]]>
    </description>
    <internalKey>operatorEq</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>operatorEqRetRefThis</key>
    <name>'operator=' should return reference to 'this' instance</name>
    <description>
      <![CDATA[
'operator=' should return reference to 'this' instance.
]]>
    </description>
    <internalKey>operatorEqRetRefThis</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>operatorEqToSelf</key>
    <name>'operator=' should check for assignment to self to avoid problems with dynamic memory</name>
    <description>
      <![CDATA[
'operator=' should check for assignment to self to ensure that each block of dynamically allocated memory is owned and managed by only one instance of the class.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>operatorEqToSelf</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>operatorEqVarError</key>
    <name>Member variable 'classname::' is not assigned a value in 'classname::operator='</name>
    <description>
      <![CDATA[
Member variable 'classname::' is not assigned a value in 'classname::operator='.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>operatorEqVarError</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>oppositeInnerCondition</key>
    <name>Opposite conditions in nested 'if' blocks lead to a dead code block</name>
    <description>
      <![CDATA[
Opposite conditions in nested 'if' blocks lead to a dead code block.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>oppositeInnerCondition</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>outOfBounds</key>
    <name>index is out of bounds: Supplied size 2 is larger than actual size 1</name>
    <description>
      <![CDATA[
index is out of bounds: Supplied size 2 is larger than actual size 1.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>outOfBounds</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>passedByValue</key>
    <name>Function parameter 'parametername' should be passed by reference</name>
    <description>
      <![CDATA[
Parameter 'parametername' is passed by value. It could be passed as a (const) reference which is usually faster and recommended in C++.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>passedByValue</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pointerArithBool</key>
    <name>Converting pointer arithmetic result to bool. The bool is always true unless there is undefined behaviour</name>
    <description>
      <![CDATA[
Converting pointer arithmetic result to bool. The boolean result is always true unless there is pointer arithmetic overflow, and overflow is undefined behaviour. Probably a dereference is forgotten.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>pointerArithBool</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pointerLessThanZero</key>
    <name>A pointer can not be negative so it is either pointless or an error to check if it is</name>
    <description>
      <![CDATA[
A pointer can not be negative so it is either pointless or an error to check if it is.
]]>
    </description>
    <internalKey>pointerLessThanZero</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pointerOutOfBounds</key>
    <name>Undefined behaviour, pointer arithmetic '' is out of bounds</name>
    <description>
      <![CDATA[
Undefined behaviour, pointer arithmetic '' is out of bounds. From chapter 6.5.6 in the C specification:\012"When an expression that has integer type is added to or subtracted from a pointer, .." and then "If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined."
]]>
    </description>
    <tag>bug</tag>
    <internalKey>pointerOutOfBounds</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pointerPositive</key>
    <name>A pointer can not be negative so it is either pointless or an error to check if it is not</name>
    <description>
      <![CDATA[
A pointer can not be negative so it is either pointless or an error to check if it is not.
]]>
    </description>
    <internalKey>pointerPositive</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pointerSize</key>
    <name>Size of pointer 'varname' used instead of size of its data</name>
    <description>
      <![CDATA[
Size of pointer 'varname' used instead of size of its data. This is likely to lead to a buffer overflow. You probably intend to write 'sizeof(*varname)'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>pointerSize</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>possibleBufferAccessOutOfBounds</key>
    <name>Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination)</name>
    <description>
      <![CDATA[
Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination). The source buffer is larger than the destination buffer so there is the potential for overflowing the destination buffer.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>possibleBufferAccessOutOfBounds</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>postfixOperator</key>
    <name>Prefer prefix ++/-- operators for non-primitive types</name>
    <description>
      <![CDATA[
Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>postfixOperator</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>preprocessorErrorDirective</key>
    <name>#error message</name>
    <description>
      <![CDATA[
#error message
]]>
    </description>
    <tag>bug</tag>
    <internalKey>preprocessorErrorDirective</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>publicAllocationError</key>
    <name>Possible leak in public function. The pointer 'varname' is not deallocated before it is allocated</name>
    <description>
      <![CDATA[
Possible leak in public function. The pointer 'varname' is not deallocated before it is allocated.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>publicAllocationError</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>readWriteOnlyFile</key>
    <name>Read operation on a file that was opened only for writing</name>
    <description>
      <![CDATA[
Read operation on a file that was opened only for writing.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>readWriteOnlyFile</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantAssignInSwitch</key>
    <name>Variable 'var' is reassigned a value before the old one has been used. 'break;' missing?</name>
    <description>
      <![CDATA[
Variable 'var' is reassigned a value before the old one has been used. 'break;' missing?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>redundantAssignInSwitch</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantAssignment</key>
    <name>Variable 'var' is reassigned a value before the old one has been used</name>
    <description>
      <![CDATA[
Variable 'var' is reassigned a value before the old one has been used.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>redundantAssignment</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantCondition</key>
    <name>Redundant condition: If x &gt; 11 the condition x &gt; 10 is always true</name>
    <description>
      <![CDATA[
Redundant condition: If x &gt; 11 the condition x &gt; 10 is always true.
]]>
    </description>
    <internalKey>redundantCondition</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantCopy</key>
    <name>Buffer 'var' is being written before its old content has been used</name>
    <description>
      <![CDATA[
Buffer 'var' is being written before its old content has been used.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>redundantCopy</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantCopyInSwitch</key>
    <name>Buffer 'var' is being written before its old content has been used. 'break;' missing?</name>
    <description>
      <![CDATA[
Buffer 'var' is being written before its old content has been used. 'break;' missing?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>redundantCopyInSwitch</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantCopyLocalConst</key>
    <name>Use const reference for 'varname' to avoid unnecessary data copying</name>
    <description>
      <![CDATA[
The const variable 'varname' is assigned a copy of the data. You can avoid the unnecessary data copying by converting 'varname' to const reference.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>redundantCopyLocalConst</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantIfRemove</key>
    <name>Redundant checking of STL container element existence before removing it</name>
    <description>
      <![CDATA[
Redundant checking of STL container element existence before removing it. It is safe to call the remove method on a non-existing element.
]]>
    </description>
    <internalKey>redundantIfRemove</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>resourceLeak</key>
    <name>Resource leak: varname</name>
    <description>
      <![CDATA[
<p>
Resource leak: varname
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/775.html" target="_blank">CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>resourceLeak</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>returnAddressOfAutoVariable</key>
    <name>Address of an auto-variable returned</name>
    <description>
      <![CDATA[
Address of an auto-variable returned.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>returnAddressOfAutoVariable</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>returnAddressOfFunctionParameter</key>
    <name>Address of function parameter 'parameter' returned</name>
    <description>
      <![CDATA[
Address of the function parameter 'parameter' becomes invalid after the function exits because function parameters are stored on the stack which is freed when the function exits. Thus the returned value is invalid.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>returnAddressOfFunctionParameter</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>returnLocalVariable</key>
    <name>Pointer to local array variable returned</name>
    <description>
      <![CDATA[
Pointer to local array variable returned.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>returnLocalVariable</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>returnReference</key>
    <name>Reference to auto variable returned</name>
    <description>
      <![CDATA[
Reference to auto variable returned.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>returnReference</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>returnTempReference</key>
    <name>Reference to temporary returned</name>
    <description>
      <![CDATA[
Reference to temporary returned.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>returnTempReference</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>seekOnAppendedFile</key>
    <name>Repositioning operation performed on a file opened in append mode has no effect</name>
    <description>
      <![CDATA[
Repositioning operation performed on a file opened in append mode has no effect.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>seekOnAppendedFile</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>selfAssignment</key>
    <name>Redundant assignment of 'varname' to itself</name>
    <description>
      <![CDATA[
Redundant assignment of 'varname' to itself.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>selfAssignment</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>selfInitialization</key>
    <name>Member variable 'var' is initialized by itself</name>
    <description>
      <![CDATA[
Member variable 'var' is initialized by itself.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>selfInitialization</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>shiftNegative</key>
    <name>Shifting by a negative value is undefined behaviour</name>
    <description>
      <![CDATA[
Shifting by a negative value is undefined behaviour
]]>
    </description>
    <tag>bug</tag>
    <internalKey>shiftNegative</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>shiftTooManyBits</key>
    <name>Shifting 32-bit value by 64 bits is undefined behaviour</name>
    <description>
      <![CDATA[
Shifting 32-bit value by 64 bits is undefined behaviour
]]>
    </description>
    <tag>bug</tag>
    <internalKey>shiftTooManyBits</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>signConversion</key>
    <name>Suspicious code: sign conversion of var in calculation, even though var can have a negative value</name>
    <description>
      <![CDATA[
Suspicious code: sign conversion of var in calculation, even though var can have a negative value
]]>
    </description>
    <tag>bug</tag>
    <internalKey>signConversion</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeArgumentAsChar</key>
    <name>The size argument is given as a char constant</name>
    <description>
      <![CDATA[
The size argument is given as a char constant.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sizeArgumentAsChar</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeofCalculation</key>
    <name>Found calculation inside sizeof()</name>
    <description>
      <![CDATA[
Found calculation inside sizeof().
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sizeofCalculation</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeofDereferencedVoidPointer</key>
    <name>'*varname' is of type 'void', the behaviour of 'sizeof(void)' is not covered by the ISO C standard</name>
    <description>
      <![CDATA[
'*varname' is of type 'void', the behaviour of 'sizeof(void)' is not covered by the ISO C standard. A value for 'sizeof(void)' is defined only as part of a GNU C extension, which defines 'sizeof(void)' to be 1.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sizeofDereferencedVoidPointer</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeofDivisionMemfunc</key>
    <name>Division by result of sizeof(). memset() expects a size in bytes, did you intend to multiply instead?</name>
    <description>
      <![CDATA[
Division by result of sizeof(). memset() expects a size in bytes, did you intend to multiply instead?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sizeofDivisionMemfunc</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeofVoid</key>
    <name>Behaviour of 'sizeof(void)' is not covered by the ISO C standard</name>
    <description>
      <![CDATA[
Behaviour of 'sizeof(void)' is not covered by the ISO C standard. A value for 'sizeof(void)' is defined only as part of a GNU C extension, which defines 'sizeof(void)' to be 1.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sizeofVoid</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeofsizeof</key>
    <name>Calling 'sizeof' on 'sizeof'</name>
    <description>
      <![CDATA[
Calling sizeof for 'sizeof looks like a suspicious code and most likely there should be just one 'sizeof'. The current code is equivalent to 'sizeof(size_t)'
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sizeofsizeof</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeofwithnumericparameter</key>
    <name>Suspicious usage of 'sizeof' with a numeric constant as parameter</name>
    <description>
      <![CDATA[
It is unusual to use a constant value with sizeof. For example, 'sizeof(10)' returns 4 (in 32-bit systems) or 8 (in 64-bit systems) instead of 10. 'sizeof('A')' and 'sizeof(char)' can return different results.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sizeofwithnumericparameter</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeofwithsilentarraypointer</key>
    <name>Using 'sizeof' on array given as function argument returns size of a pointer</name>
    <description>
      <![CDATA[
Using 'sizeof' for array given as function argument returns the size of a pointer. It does not return the size of the whole array in bytes as might be expected. For example, this code:\012     int f(char a[100]) {\012         return sizeof(a);\012     }\012returns 4 (in 32-bit systems) or 8 (in 64-bit systems) instead of 100 (the size of the array in bytes).
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sizeofwithsilentarraypointer</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sprintfOverlappingData</key>
    <name>Undefined behavior: Variable 'varname' is used as parameter and destination in s[n]printf()</name>
    <description>
      <![CDATA[
The variable 'varname' is used both as a parameter and as destination in s[n]printf(). The origin and destination buffers overlap. Quote from glibc (C-library) documentation (http://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Output-Functions): "If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results are undefined."
]]>
    </description>
    <tag>bug</tag>
    <internalKey>sprintfOverlappingData</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>staticStringCompare</key>
    <name>Unnecessary comparison of static strings</name>
    <description>
      <![CDATA[
The compared strings, 'str1' and 'str2', are always unequal. Therefore the comparison is unnecessary and looks suspicious.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>staticStringCompare</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlBoundaries</key>
    <name>Dangerous iterator comparison using operator&lt; on 'std::container'</name>
    <description>
      <![CDATA[
Iterator of container 'std::container' compared with operator&lt;. This is dangerous since the order of items in the container is not guaranteed. One should use operator!= instead to compare iterators.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlBoundaries</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlIfFind</key>
    <name>Suspicious condition. The result of find() is an iterator, but it is not properly checked</name>
    <description>
      <![CDATA[
Suspicious condition. The result of find() is an iterator, but it is not properly checked.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlIfFind</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlIfStrFind</key>
    <name>Inefficient usage of string::find() in condition; string::compare() would be faster</name>
    <description>
      <![CDATA[
Either inefficient or wrong usage of string::find(). string::compare() will be faster if string::find's result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlIfStrFind</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlOutOfBounds</key>
    <name>When i==foo.size(), foo[i] is out of bounds</name>
    <description>
      <![CDATA[
When i==foo.size(), foo[i] is out of bounds.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlOutOfBounds</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlSize</key>
    <name>Possible inefficient checking for 'list' emptiness</name>
    <description>
      <![CDATA[
Checking for 'list' emptiness might be inefficient. Using list.empty() instead of list.size() can be faster. list.size() can take linear time but list.empty() is guaranteed to take constant time.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlSize</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlcstr</key>
    <name>Dangerous usage of c_str(). The value returned by c_str() is invalid after this call</name>
    <description>
      <![CDATA[
Dangerous usage of c_str(). The c_str() return value is only valid until its string is deleted.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlcstr</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlcstrParam</key>
    <name>Passing the result of c_str() to a function that takes std::string as argument no. 0 is slow and redundant</name>
    <description>
      <![CDATA[
The conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly passing the string.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlcstrParam</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlcstrReturn</key>
    <name>Returning the result of c_str() in a function that returns std::string is slow and redundant</name>
    <description>
      <![CDATA[
The conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly returning the string.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlcstrReturn</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>strPlusChar</key>
    <name>Unusual pointer arithmetic. A value of type 'char' is added to a string literal</name>
    <description>
      <![CDATA[
Unusual pointer arithmetic. A value of type 'char' is added to a string literal.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>strPlusChar</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stringCompare</key>
    <name>Comparison of identical string variables</name>
    <description>
      <![CDATA[
The compared strings, 'varname1' and 'varname2', are identical. This could be a logic bug.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stringCompare</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>strncatUsage</key>
    <name>Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append</name>
    <description>
      <![CDATA[
At most, strncat appends the 3rd parameter's amount of characters and adds a terminating null byte.\012The safe way to use strncat is to subtract one from the remaining space in the buffer and use it as 3rd parameter.Source: http://www.cplusplus.com/reference/cstring/strncat/\012Source: http://www.opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncat.c
]]>
    </description>
    <tag>bug</tag>
    <internalKey>strncatUsage</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>suspiciousSemicolon</key>
    <name>Suspicious use of ; at the end of '' statement</name>
    <description>
      <![CDATA[
Suspicious use of ; at the end of '' statement.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>suspiciousSemicolon</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>switchCaseFallThrough</key>
    <name>Switch falls through case without comment. 'break;' missing?</name>
    <description>
      <![CDATA[
Switch falls through case without comment. 'break;' missing?
]]>
    </description>
    <internalKey>switchCaseFallThrough</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>terminateStrncpy</key>
    <name>The buffer 'buffer' may not be null-terminated after the call to strncpy()</name>
    <description>
      <![CDATA[
If the source string's size fits or exceeds the given size, strncpy() does not add a zero at the end of the buffer. This causes bugs later in the code if the code assumes buffer is null-terminated.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>terminateStrncpy</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>thisSubtraction</key>
    <name>Suspicious pointer subtraction. Did you intend to write '-&gt;'?</name>
    <description>
      <![CDATA[
Suspicious pointer subtraction. Did you intend to write '-&gt;'?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>thisSubtraction</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>toomanyconfigs</key>
    <name>Too many #ifdef configurations - cppcheck only checks 12 configurations. Use --force to check all configurations. For more details, use --enable=information</name>
    <description>
      <![CDATA[
The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. For more details, use --enable=information.
]]>
    </description>
    <internalKey>toomanyconfigs</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unassignedVariable</key>
    <name>Variable 'varname' is not assigned a value</name>
    <description>
      <![CDATA[
Variable 'varname' is not assigned a value.
]]>
    </description>
    <internalKey>unassignedVariable</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uninitMemberVar</key>
    <name>Member variable 'classname::varname' is not initialized in the constructor</name>
    <description>
      <![CDATA[
Member variable 'classname::varname' is not initialized in the constructor.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uninitMemberVar</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uninitStructMember</key>
    <name>Uninitialized struct member: a.b</name>
    <description>
      <![CDATA[
Uninitialized struct member: a.b
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uninitStructMember</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uninitdata</key>
    <name>Memory is allocated but not initialized: varname</name>
    <description>
      <![CDATA[
Memory is allocated but not initialized: varname
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uninitdata</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uninitstring</key>
    <name>Dangerous usage of 'varname' (strncpy doesn't always null-terminate it)</name>
    <description>
      <![CDATA[
Dangerous usage of 'varname' (strncpy doesn't always null-terminate it).
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uninitstring</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uninitvar</key>
    <name>Uninitialized variable: varname</name>
    <description>
      <![CDATA[
Uninitialized variable: varname
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uninitvar</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unnecessaryForwardDeclaration</key>
    <name>The variable 'name' forward declaration is unnecessary. Type variable is already declared earlier</name>
    <description>
      <![CDATA[
The variable 'name' forward declaration is unnecessary. Type variable is already declared earlier.
]]>
    </description>
    <internalKey>unnecessaryForwardDeclaration</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unnecessaryQualification</key>
    <name>The extra qualification 'type' is unnecessary and is considered an error by many compilers</name>
    <description>
      <![CDATA[
The extra qualification 'type' is unnecessary and is considered an error by many compilers.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>unnecessaryQualification</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unpreciseMathCall</key>
    <name>Expression '1 - erf(x)' can be replaced by 'erfc(x)' to avoid loss of precision</name>
    <description>
      <![CDATA[
Expression '1 - erf(x)' can be replaced by 'erfc(x)' to avoid loss of precision.
]]>
    </description>
    <internalKey>unpreciseMathCall</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unreachableCode</key>
    <name>Statements following return, break, continue, goto or throw will never be executed</name>
    <description>
      <![CDATA[
Statements following return, break, continue, goto or throw will never be executed.
]]>
    </description>
    <internalKey>unreachableCode</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unreadVariable</key>
    <name>Variable 'varname' is assigned a value that is never used</name>
    <description>
      <![CDATA[
Variable 'varname' is assigned a value that is never used.
]]>
    </description>
    <internalKey>unreadVariable</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unsafeClassCanLeak</key>
    <name>Class 'class' is unsafe, 'class::varname' can leak by wrong usage</name>
    <description>
      <![CDATA[
The class 'class' is unsafe, wrong usage can cause memory/resource leaks for 'class::varname'. This can for instance be fixed by adding proper cleanup in the destructor.
]]>
    </description>
    <internalKey>unsafeClassCanLeak</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unsignedLessThanZero</key>
    <name>Checking if unsigned variable 'varname' is less than zero</name>
    <description>
      <![CDATA[
The unsigned variable 'varname' will never be negative so it is either pointless or an error to check if it is.
]]>
    </description>
    <internalKey>unsignedLessThanZero</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unsignedPositive</key>
    <name>Unsigned variable 'varname' can't be negative so it is unnecessary to test it</name>
    <description>
      <![CDATA[
Unsigned variable 'varname' can't be negative so it is unnecessary to test it.
]]>
    </description>
    <internalKey>unsignedPositive</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unusedAllocatedMemory</key>
    <name>Variable 'varname' is allocated memory that is never used</name>
    <description>
      <![CDATA[
Variable 'varname' is allocated memory that is never used.
]]>
    </description>
    <internalKey>unusedAllocatedMemory</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unusedFunction</key>
    <name>The function 'funcName' is never used</name>
    <description>
      <![CDATA[
The function 'funcName' is never used.
]]>
    </description>
    <internalKey>unusedFunction</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unusedPrivateFunction</key>
    <name>Unused private function: 'classname::funcname'</name>
    <description>
      <![CDATA[
Unused private function: 'classname::funcname'
]]>
    </description>
    <internalKey>unusedPrivateFunction</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unusedScopedObject</key>
    <name>Instance of 'varname' object is destroyed immediately</name>
    <description>
      <![CDATA[
Instance of 'varname' object is destroyed immediately.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>unusedScopedObject</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unusedStructMember</key>
    <name>struct or union member 'structname::variable' is never used</name>
    <description>
      <![CDATA[
struct or union member 'structname::variable' is never used.
]]>
    </description>
    <internalKey>unusedStructMember</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unusedVariable</key>
    <name>Unused variable: varname</name>
    <description>
      <![CDATA[
Unused variable: varname
]]>
    </description>
    <internalKey>unusedVariable</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>useAutoPointerArray</key>
    <name>Object pointed by an 'auto_ptr' is destroyed using operator 'delete'. You should not use 'auto_ptr' for pointers obtained with operator 'new[]'</name>
    <description>
      <![CDATA[
Object pointed by an 'auto_ptr' is destroyed using operator 'delete'. This means that you should only use 'auto_ptr' for pointers obtained with operator 'new'. This excludes arrays, which are allocated by operator 'new[]' and must be deallocated by operator 'delete[]'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>useAutoPointerArray</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>useAutoPointerContainer</key>
    <name>You can randomly lose access to pointers if you store 'auto_ptr' pointers in an STL container</name>
    <description>
      <![CDATA[
An element of container must be able to be copied but 'auto_ptr' does not fulfill this requirement. You should consider to use 'shared_ptr' or 'unique_ptr'. It is suitable for use in containers, because they no longer copy their values, they move them.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>useAutoPointerContainer</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>useAutoPointerCopy</key>
    <name>Copying 'auto_ptr' pointer to another does not create two equal objects since one has lost its ownership of the pointer</name>
    <description>
      <![CDATA[
'std::auto_ptr' has semantics of strict ownership, meaning that the 'auto_ptr' instance is the sole entity responsible for the object's lifetime. If an 'auto_ptr' is copied, the source looses the reference.
]]>
    </description>
    <internalKey>useAutoPointerCopy</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>useClosedFile</key>
    <name>Used file that is not opened</name>
    <description>
      <![CDATA[
Used file that is not opened.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>useClosedFile</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>useInitializationList</key>
    <name>Variable 'variable' is assigned in constructor body. Consider performing initialization in initialization list</name>
    <description>
      <![CDATA[
When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'variable' a value by passing the value to the constructor in the initialization list.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>useInitializationList</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uselessAssignmentArg</key>
    <name>Assignment of function parameter has no effect outside the function</name>
    <description>
      <![CDATA[
Assignment of function parameter has no effect outside the function.
]]>
    </description>
    <internalKey>uselessAssignmentArg</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uselessAssignmentPtrArg</key>
    <name>Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?</name>
    <description>
      <![CDATA[
Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uselessAssignmentPtrArg</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uselessCallsCompare</key>
    <name>It is inefficient to call 'str.find(str)' as it always returns 0</name>
    <description>
      <![CDATA[
'std::string::find()' returns zero when given itself as parameter (str.find(str)). As it is currently the code is inefficient. It is possible either the string searched ('str') or searched for ('str') is wrong.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uselessCallsCompare</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uselessCallsEmpty</key>
    <name>Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead?</name>
    <description>
      <![CDATA[
Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uselessCallsEmpty</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uselessCallsRemove</key>
    <name>Return value of std::remove() ignored. Elements remain in container</name>
    <description>
      <![CDATA[
The return value of std::remove() is ignored. This function returns an iterator to the end of the range containing those elements that should be kept. Elements past new end remain valid but with unspecified values. Use the erase method of the container to delete them.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uselessCallsRemove</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uselessCallsSubstr</key>
    <name>Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead</name>
    <description>
      <![CDATA[
Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uselessCallsSubstr</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uselessCallsSwap</key>
    <name>It is inefficient to swap a object with itself by calling 'str.swap(str)'</name>
    <description>
      <![CDATA[
The 'swap()' function has no logical effect when given itself as parameter (str.swap(str)). As it is currently the code is inefficient. Is the object or the parameter wrong here?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>uselessCallsSwap</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>va_end_missing</key>
    <name>va_list 'vl' was opened but not closed by va_end()</name>
    <description>
      <![CDATA[
va_list 'vl' was opened but not closed by va_end().
]]>
    </description>
    <tag>bug</tag>
    <internalKey>va_end_missing</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>va_list_usedBeforeStarted</key>
    <name>va_list 'vl' used before va_start() was called</name>
    <description>
      <![CDATA[
va_list 'vl' used before va_start() was called.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>va_list_usedBeforeStarted</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>va_start_referencePassed</key>
    <name>Using reference 'arg1' as parameter for va_start() results in undefined behaviour</name>
    <description>
      <![CDATA[
Using reference 'arg1' as parameter for va_start() results in undefined behaviour.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>va_start_referencePassed</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>va_start_subsequentCalls</key>
    <name>va_start() or va_copy() called subsequently on 'vl' without va_end() inbetween</name>
    <description>
      <![CDATA[
va_start() or va_copy() called subsequently on 'vl' without va_end() inbetween.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>va_start_subsequentCalls</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>va_start_wrongParameter</key>
    <name>'arg1' given to va_start() is not last named argument of the function. Did you intend to pass 'arg2'?</name>
    <description>
      <![CDATA[
'arg1' given to va_start() is not last named argument of the function. Did you intend to pass 'arg2'?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>va_start_wrongParameter</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>varFuncNullUB</key>
    <name>Passing NULL after the last typed argument to a variadic function leads to undefined behaviour</name>
    <description>
      <![CDATA[
Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\012The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\012The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\012In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.\012To reproduce you might be able to use this little code example on 64bit platforms. If the output includes "ERROR", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the "ERROR" output go away.\012#include &lt;stdarg.h&gt;\012#include &lt;stdio.h&gt;\012\012void f(char *s, ...) {\012    va_list ap;\012    va_start(ap,s);\012    for (;;) {\012        char *p = va_arg(ap,char*);\012        printf("%018p, %s\n", p, (long)p &amp; 255 ? p : "");\012        if(!p) break;\012    }\012    va_end(ap);\012}\012\012void g() {\012    char *s2 = "x";\012    char *s3 = "ERROR";\012\012    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64\012    f("first", s2, s2, s2, s2, s2, 0, s3, (char*)0);\012}\012\012void h() {\012    int i;\012    volatile unsigned char a[1000];\012    for (i = 0; i&lt;sizeof(a); i++)\012        a[i] = -1;\012}\012\012int main() {\012    h();\012    g();\012    return 0;\012}
]]>
    </description>
    <tag>bug</tag>
    <internalKey>varFuncNullUB</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>variableHidingEnum</key>
    <name>variable 'name' hides enumerator with same name</name>
    <description>
      <![CDATA[
variable 'name' hides enumerator with same name
]]>
    </description>
    <internalKey>variableHidingEnum</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>variableHidingTypedef</key>
    <name>The variable 'name' hides a typedef with the same name</name>
    <description>
      <![CDATA[
The variable 'name' hides a typedef with the same name.
]]>
    </description>
    <internalKey>variableHidingTypedef</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>variableScope</key>
    <name>The scope of the variable 'varname' can be reduced</name>
    <description>
      <![CDATA[
The scope of the variable 'varname' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:\012void f(int x)\012{\012    int i = 0;\012    if (x) {\012        // it's safe to move 'int i = 0;' here\012        for (int n = 0; n < 10; ++n) {\012            // it is possible but not safe to move 'int i = 0;' here\012            do_something(&amp;i);\012        }\012    }\012}\012When you see this message it is always safe to reduce the variable scope 1 level.
]]>
    </description>
    <internalKey>variableScope</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>virtualDestructor</key>
    <name>Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor</name>
    <description>
      <![CDATA[
Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. If you destroy instances of the derived class by deleting a pointer that points to the base class, only the destructor of the base class is executed. Thus, dynamic memory that is managed by the derived class could leak. This can be avoided by adding a virtual destructor to the base class.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>virtualDestructor</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>writeReadOnlyFile</key>
    <name>Write operation on a file that was opened only for reading</name>
    <description>
      <![CDATA[
Write operation on a file that was opened only for reading.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>writeReadOnlyFile</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wrongPipeParameterSize</key>
    <name>Buffer 'varname' must have size of 2 integers if used as parameter of pipe()</name>
    <description>
      <![CDATA[
The pipe()/pipe2() system command takes an argument, which is an array of exactly two integers.\012The variable 'varname' is an array of size dimension, which does not match.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>wrongPipeParameterSize</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wrongPrintfScanfArgNum</key>
    <name>printf format string requires 3 parameters but only 2 are given</name>
    <description>
      <![CDATA[
printf format string requires 3 parameters but only 2 are given.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>wrongPrintfScanfArgNum</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wrongPrintfScanfParameterPositionError</key>
    <name>printf: referencing parameter 2 while 1 arguments given</name>
    <description>
      <![CDATA[
printf: referencing parameter 2 while 1 arguments given
]]>
    </description>
    <tag>bug</tag>
    <internalKey>wrongPrintfScanfParameterPositionError</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wrongmathcall</key>
    <name>Passing value '#' to #() leads to implementation-defined result</name>
    <description>
      <![CDATA[
Passing value '#' to #() leads to implementation-defined result.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>wrongmathcall</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>zerodiv</key>
    <name>Division by zero</name>
    <description>
      <![CDATA[
Division by zero.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>zerodiv</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>zerodivcond</key>
    <name>Either the condition '' is useless or there is division by zero at line 0</name>
    <description>
      <![CDATA[
Either the condition '' is useless or there is division by zero at line 0.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>zerodivcond</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>comparisonOfBoolWithInvalidComparator</key>
    <name>Comparison of a boolean value using relational operator (&lt;, &gt;, &lt;= or &gt;=)</name>
    <description>
      <![CDATA[
The result of the expression 'expression' is of type 'bool'. Comparing 'bool' value using relational (&lt;, &gt;, &lt;= or &gt;=) operator could cause unexpected results.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>comparisonOfBoolWithInvalidComparator</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>identicalConditionAfterEarlyExit</key>
    <name>Identical condition 'x', second condition is always false</name>
    <description>
      <![CDATA[
<p>
Identical condition 'x', second condition is always false
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>identicalConditionAfterEarlyExit</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidFree</key>
    <name>Mismatching address is freed. The address you get from malloc() must be freed without offset</name>
    <description>
      <![CDATA[
Mismatching address is freed. The address you get from malloc() must be freed without offset.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidFree</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantBitwiseOperationInSwitch</key>
    <name>Redundant bitwise operation on 'varname' in 'switch' statement. 'break;' missing?</name>
    <description>
      <![CDATA[
Redundant bitwise operation on 'varname' in 'switch' statement. 'break;' missing?
]]>
    </description>
    <tag>bug</tag>
    <internalKey>redundantBitwiseOperationInSwitch</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>shiftTooManyBitsSigned</key>
    <name>Shifting signed 32-bit value by 31 bits is implementation-defined behaviour</name>
    <description>
      <![CDATA[
<p>
Shifting signed 32-bit value by 31 bits is implementation-defined
behaviour
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>shiftTooManyBitsSigned</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlcstrthrow</key>
    <name>Dangerous usage of c_str(). The value returned by c_str() is invalid after throwing exception</name>
    <description>
      <![CDATA[
Dangerous usage of c_str(). The string is destroyed after the c_str() call so the thrown pointer is invalid.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>stlcstrthrow</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.69 Dev ########### -->
  <rule>
    <key>duplicateExpressionTernary</key>
    <name>Same expression in both branches of ternary operator</name>
    <description>
      <![CDATA[
<p>
Finding the same expression in both branches of ternary operator is
suspicious as the same code is executed regardless of the condition.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>bug</tag>
    <tag>cwe</tag>
    <internalKey>duplicateExpressionTernary</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>noExplicitConstructor</key>
    <name>Class has a constructor with 1 argument that is not explicit</name>
    <description>
      <![CDATA[
<p>
Class 'classname' has a constructor with 1 argument that is not
explicit. Such constructors should in general be explicit for type
safety reasons. Using the explicit keyword in the constructor means
some mistakes when using the class can be avoided.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>noExplicitConstructor</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>noExplicitCopyMoveConstructor</key>
    <name>Abstract class has a copy/move constructor that is not explicit</name>
    <description>
      Abstract class &apos;classname&apos; has a copy/move constructor that is not explicit.
    </description>
    <internalKey>noExplicitCopyMoveConstructor</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>operatorEqMissingReturnStatement</key>
    <name>No 'return' statement in non-void function causes undefined behavior</name>
    <description>
      <![CDATA[
<p>
No <code>return</code> statement in non-void function causes undefined behavior.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>operatorEqMissingReturnStatement</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>operatorEqShouldBeLeftUnimplemented</key>
    <name>'operator=' should either return reference to 'this'</name>
    <description>
      <![CDATA[
<p>
'operator=' should either return reference to 'this' instance or be
declared private and left unimplemented.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>operatorEqShouldBeLeftUnimplemented</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantPointerOp</key>
    <name>Redundant pointer operation on varname</name>
    <description>
      <![CDATA[
<p>
Redundant pointer operation on 'varname' - it's already a pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>redundantPointerOp</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>throwInNoexceptFunction</key>
    <name>Exception thrown in function declared not to throw exceptions</name>
    <description>
      <![CDATA[
<p>
Exception thrown in function declared not to throw exceptions.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>throwInNoexceptFunction</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>useAutoPointerMalloc</key>
    <name>Object pointed by an 'auto_ptr' is destroyed using operator 'delete'</name>
    <description>
      <![CDATA[
<p>
Object pointed by an 'auto_ptr' is destroyed using operator 'delete'.
You should not use 'auto_ptr' for pointers obtained with function
'malloc'. This means that you should only use 'auto_ptr' for pointers
obtained with operator 'new'. This excludes use C library allocation
functions (for example 'malloc'), which must be deallocated by the
appropriate C library function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>useAutoPointerMalloc</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.70 release ########### -->
  <rule>
    <key>negativeArraySize</key>
    <name>Declaration of array with negative size is undefined behaviour</name>
    <description>
      <![CDATA[<p>
Declaration of array with negative size is undefined behaviour
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
    <internalKey>negativeArraySize</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>badBitmaskCheck</key>
    <name>Result of operator '|' is always true if one operand is non-zero</name>
    <description>
      <![CDATA[
<p>
Result of operator '|' is always true if one operand is non-zero. Did
you intend to use '&amp;'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cwe</tag>
    <internalKey>badBitmaskCheck</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>knownConditionTrueFalse</key>
    <name>Condition is always true/false</name>
    <description>
      <![CDATA[<p>
Condition 'x' is always true/false.
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cwe</tag>
    <internalKey>knownConditionTrueFalse</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nullPointerDefaultArg</key>
    <name>Possible null pointer dereference if the default parameter value is used: pointer</name>
    <description>
      <![CDATA[
<p>
Possible null pointer dereference if the default parameter value is
used
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/476.html" target="_blank">CWE-476: NULL Pointer Dereference</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <tag>cert</tag>
    <internalKey>nullPointerDefaultArg</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nullPointerRedundantCheck</key>
    <name>Either the condition is redundant or there is possible null pointer dereference: pointer</name>
    <description>
      <![CDATA[
<p>
Either the condition is redundant or there is possible null pointer
dereference
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/476.html" target="_blank">CWE-476: NULL Pointer Dereference</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
    <internalKey>nullPointerRedundantCheck</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>obsoleteFunctionsalloca</key>
    <name>Obsolete function &apos;alloca&apos; called</name>
    <description>
      Obsolete function &apos;alloca&apos; called. In C99 and later it is recommended to use a variable length array instead.
    </description>
    <tag>cwe</tag>
    <internalKey>obsoleteFunctionsalloca</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>raceAfterInterlockedDecrement</key>
    <name>Race condition: non-interlocked access after InterlockedDecrement()</name>
    <description>
      <![CDATA[
<p>
Race condition: non-interlocked access after InterlockedDecrement().
Use InterlockedDecrement() return value instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/362.html" target="_blank">CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>raceAfterInterlockedDecrement</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unusedLabel</key>
    <name>Label is not used</name>
    <description>
      <![CDATA[
<p>
Label is not used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>unusedLabel</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stringLiteralWrite</key>
    <name>Modifying string literal directly or indirectly is undefined behaviour</name>
    <description>
      <![CDATA[
<p>
Modifying string literal directly or indirectly is undefined
behaviour.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>bug</tag>
    <tag>cwe</tag>
    <internalKey>stringLiteralWrite</internalKey>
    <severity>CRITICAL</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>truncLongCastAssignment</key>
    <name>int result is assigned to long variable (potential truncation)</name>
    <description>
      <![CDATA[
<p>
int result is assigned to long variable. If the variable is long to
avoid loss of information, then there is loss of information. To avoid
loss of information you must cast a calculation operand to long, for
example 'l = a * b;' => 'l = (long)a * b;'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/197.html" target="_blank">CWE-197: Numeric Truncation Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>truncLongCastAssignment</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>truncLongCastReturn</key>
    <name>int result is returned as long value (potential truncation)</name>
    <description>
      <![CDATA[
<p>
int result is returned as long value. If the return value is long to
avoid loss of information, then there is loss of information. To avoid
loss of information you must cast a calculation operand to long, for
example 'return a*b;' => 'return (long)a*b'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/197.html" target="_blank">CWE-197: Numeric Truncation Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>truncLongCastReturn</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.72 ########### -->
  <rule>
    <key>assignBoolToFloat</key>
    <name>Boolean value assigned to floating point variable</name>
    <description>
      <![CDATA[<p>
Boolean value assigned to floating point variable.
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/704.html" target="_blank">CWE-704: Incorrect Type Conversion or Cast</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>assignBoolToFloat</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidTestForOverflow</key>
    <name>Invalid test for overflow (undefined behavior)</name>
    <description>
      <![CDATA[
<p>
Invalid test for overflow 'x + u < x'. Condition is always false
unless there is overflow, and overflow is undefined behaviour.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>invalidTestForOverflow</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unknownEvaluationOrder</key>
    <name>Expression depends on order of evaluation (side effects)</name>
    <description>
      <![CDATA[
<p>
Expression 'x = x++;' depends on order of evaluation of side effects
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/768.html" target="_blank">CWE-768: Incorrect Short Circuit Evaluation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>unknownEvaluationOrder</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.73 ########### -->
  <rule>
    <key>signedCharArrayIndex</key>
    <name>Signed 'char' type used as array index</name>
    <description>
      <![CDATA[
<p>
Signed 'char' type used as array index. If the value can be greater
than 127 there will be a buffer underflow because of sign extension.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/128.html" target="_blank">CWE-128: Wrap-around Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>signedCharArrayIndex</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unknownSignCharArrayIndex</key>
    <name>'char' type used as array index</name>
    <description>
      <![CDATA[
<p>
'char' type used as array index. Values greater that 127 will be
treated depending on whether 'char' is signed or unsigned on target
platform.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>unknownSignCharArrayIndex</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unusedLabelSwitch</key>
    <name>Label is not used. </name>
    <description>
      <![CDATA[
<p>
Label is not used. Should this be a 'case' of the enclosing
switch()?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>unusedLabelSwitch</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.76 ########### -->
  <!-- this warnings is not reported by "cppcheck -errorlist" -->
  <rule>
    <key>leakUnsafeArgAlloc</key>
    <name>Unsafe allocation. If 'funcName()' throws, memory could be leaked</name>
    <description>
      <![CDATA[
<p>
Unsafe allocation. If funcName() throws, memory could be leaked. Use
make_shared&lt;T&gt;() / make_unique&lt;T&gt;() instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/401.html" target="_blank">CWE-401: Improper Release of Memory Before Removing Last Reference</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>leakUnsafeArgAlloc</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>suspiciousCase</key>
    <name>Found suspicious case label in switch()</name>
    <description>
      <![CDATA[
<p>
Using an operator like '||' in a case label is suspicious. Did you
intend to use a bitwise operator, multiple case labels or if/else
instead?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>suspiciousCase</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>suspiciousEqualityComparison</key>
    <name>Found suspicious equality comparison</name>
    <description>
      <![CDATA[
<p>
Found suspicious equality comparison. Did you intend to assign a value
instead?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/482.html" target="_blank">CWE-482: Comparing instead of Assigning</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>suspiciousEqualityComparison</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>multiplySizeof</key>
    <name>Multiplying sizeof() with sizeof()</name>
    <description>
      <![CDATA[<p>
Multiplying sizeof() with sizeof() indicates a logic error.
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>multiplySizeof</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>divideSizeof</key>
    <name>Division of result of sizeof() on pointer type</name>
    <description>
      <![CDATA[
<p>
Division of result of sizeof() on pointer type. sizeof() returns the
size of the pointer, not the size of the memory area it points to.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>divideSizeof</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>reademptycontainer</key>
    <name>Reading from empty STL container</name>
    <description>
      <![CDATA[<p>
Reading from empty STL container.
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: Indicator of Poor Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>reademptycontainer</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.77 ########### -->
  <rule>
    <key>nullPointerArithmetic</key>
    <name>Pointer arithmetic with NULL pointer</name>
    <description>
      <![CDATA[
<p>
Pointer arithmetic with NULL pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>nullPointerArithmetic</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>shiftNegativeLHS</key>
    <name>Shifting a negative value is technically undefined behaviour</name>
    <description>
      <![CDATA[
<p>
Shifting a negative value is technically undefined behaviour
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>shiftNegativeLHS</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>accessMoved</key>
    <name>Access of moved variable 'name'</name>
    <description>
      <![CDATA[
<p>
Access of moved variable 'name'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/672.html" target="_blank">CWE-672: Operation on a Resource after Expiration or Release</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>accessMoved</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>accessForwarded</key>
    <name>Access of forwarded variable 'name'</name>
    <description>
      <![CDATA[<p>
Access of forwarded variable 'name'.
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/672.html" target="_blank">CWE-672: Operation on a Resource after Expiration or Release</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>accessForwarded</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>floatConversionOverflow</key>
    <name>Undefined behaviour: float to integer conversion overflow</name>
    <description>
      <![CDATA[
<p>
Undefined behaviour: float to integer conversion overflow.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/190.html" target="_blank">CWE-190: Integer Overflow or Wraparound</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>floatConversionOverflow</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.78 ########### -->
  <rule>
    <key>funcArgNamesDifferent</key>
    <name>Different argument name in function declaration and definition</name>
    <description>
      <![CDATA[
<p>
Different argument name in function declaration and function definition.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>funcArgNamesDifferent</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>funcArgOrderDifferent</key>
    <name>Different argument order in function declaration and definition</name>
    <description>
      <![CDATA[
<p>
Different argument order in function declaration and function definition
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/683.html" target="_blank">CWE-683: Function Call With Incorrect Order of Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>funcArgOrderDifferent</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>copyCtorAndEqOperator</key>
    <name>The class 'class' has 'operator=' but lack of 'copy constructor'</name>
    <description>
      <![CDATA[
The class 'class' has 'operator=' but lack of 'copy constructor'.
    ]]>
    </description>
    <internalKey>copyCtorAndEqOperator</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.82 ########### -->
  <rule>
    <key>unsafeClassDivZero</key>
    <name>Public interface of Class is not safe</name>
    <description>
      <![CDATA[
Public interface of Class is not safe. When calling Class::dostuff(), if parameter x is 0 that leads to division by zero.
    ]]>
    </description>
    <internalKey>unsafeClassDivZero</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pointerAdditionResultNotNull</key>
    <name>Comparison is wrong. Result of can be 0</name>
    <description>
      <![CDATA[
Comparison is wrong. Result of 'ptr+1' can't be 0 unless there is pointer overflow, and pointer overflow is undefined behaviour.
    ]]>
    </description>
    <internalKey>pointerAdditionResultNotNull</internalKey>
    <severity>MAJOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>overlappingStrcmp</key>
    <name>Multiple suspicious overlapping strcmp</name>
    <description>
      <![CDATA[<p>
The expression 'strcmp(x,"def") != 0' is suspicious. It overlaps 'strcmp(x,"abc") == 0'.
</p>
]]>
    </description>
    <internalKey>overlappingStrcmp</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>1min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### keys matching the schema <some-function-id>Called are not listed by the simple cppcheck -errorlist          ########### -->
  <!-- ########### they become visible only if corresponding library was loaded, e.g. cppcheck -errorlist -library=posix.cfg   ########### -->
  <!-- ########### see generate_cppcheck_resources.sh for more details                                                         ########### -->
  <rule>
    <key>LocalAllocCalled</key>
    <name>Obsolete function 'LocalAlloc' called. It is recommended to use 'HeapAlloc' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'LocalAlloc' called. It is recommended to use
'HeapAlloc' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>LocalAllocCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>RtlFillBytesCalled</key>
    <name>Obsolete function 'RtlFillBytes' called. It is recommended to use 'RtlFillMemory' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'RtlFillBytes' called. It is recommended to use
'RtlFillMemory' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>RtlFillBytesCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>RtlZeroBytesCalled</key>
    <name>Obsolete function 'RtlZeroBytes' called. It is recommended to use 'RtlZeroMemory' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'RtlZeroBytes' called. It is recommended to use
'RtlZeroMemory' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>RtlZeroBytesCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>asctime_rCalled</key>
    <name>Obsolescent function 'asctime_r' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'asctime_r' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>asctime_rCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>autoVariablesAssignGlobalPointer</key>
    <name>Address of local array array is assigned to global pointer pointer and not reassigned before array goes out of scope</name>
    <description>
      <![CDATA[
<p>
Address of local array array is assigned to global pointer pointer and
not reassigned before array goes out of scope.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>autoVariablesAssignGlobalPointer</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>bcmpCalled</key>
    <name>Obsolescent function 'bcmp' called. It is recommended to use 'memcmp' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'bcmp' called. It is recommended to use 'memcmp'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>bcmpCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>bcopyCalled</key>
    <name>Obsolescent function 'bcopy' called. It is recommended to use 'memcpy' or 'memmove' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'bcopy' called. It is recommended to use 'memcpy'
or 'memmove' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>bcopyCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>bsd_signalCalled</key>
    <name>Obsolescent function 'bsd_signal' called. It is recommended to use 'sigaction' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'bsd_signal' called. It is recommended to use
'sigaction' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>bsd_signalCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>bzeroCalled</key>
    <name>Obsolescent function 'bzero' called. It is recommended to use 'memset' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'bzero' called. It is recommended to use 'memset'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>bzeroCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>cryptCalled</key>
    <name>Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'crypt' called. For threadsafe applications it
is recommended to use the reentrant replacement function 'crypt_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>cryptCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>ctermidCalled</key>
    <name>Non reentrant function 'ctermid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ctermid_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'ctermid' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'ctermid_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>ctermidCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>ctime_rCalled</key>
    <name>Obsolescent function 'ctime_r' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'ctime_r' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>ctime_rCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>ecvtCalled</key>
    <name>Obsolescent function 'ecvt' called. It is recommended to use 'sprintf' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'ecvt' called. It is recommended to use 'sprintf'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>ecvtCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>fcvtCalled</key>
    <name>Obsolescent function 'fcvt' called. It is recommended to use 'sprintf' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'fcvt' called. It is recommended to use 'sprintf'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>fcvtCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>fgetgrentCalled</key>
    <name>Non reentrant function 'fgetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetgrent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'fgetgrent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'fgetgrent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>fgetgrentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>fgetpwentCalled</key>
    <name>Non reentrant function 'fgetpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetpwent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'fgetpwent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'fgetpwent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>fgetpwentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>fgetspentCalled</key>
    <name>Non reentrant function 'fgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetspent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'fgetspent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'fgetspent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>fgetspentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>gcvtCalled</key>
    <name>Obsolescent function 'gcvt' called. It is recommended to use 'sprintf' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'gcvt' called. It is recommended to use 'sprintf'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>gcvtCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getcontextCalled</key>
    <name>Obsolescent function 'getcontext' called. Applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'getcontext' called. Applications are recommended
to be rewritten to use POSIX threads.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getcontextCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getgrentCalled</key>
    <name>Non reentrant function 'getgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getgrent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getgrent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getgrentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getgrgidCalled</key>
    <name>Non reentrant function 'getgrgid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrgid_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getgrgid' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getgrgid_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getgrgidCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getgrnamCalled</key>
    <name>Non reentrant function 'getgrnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrnam_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getgrnam' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getgrnam_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getgrnamCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>gethostbyaddrCalled</key>
    <name>Obsolescent function 'gethostbyaddr' called. It is recommended to use 'getnameinfo' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'gethostbyaddr' called. It is recommended to use
'getnameinfo' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>gethostbyaddrCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>gethostbyname2Called</key>
    <name>Non reentrant function 'gethostbyname2' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname2_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'gethostbyname2' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'gethostbyname2_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>gethostbyname2Called</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>gethostentCalled</key>
    <name>Non reentrant function 'gethostent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'gethostent' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'gethostent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>gethostentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getloginCalled</key>
    <name>Non reentrant function 'getlogin' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getlogin_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getlogin' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getlogin_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getloginCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getnetbyaddrCalled</key>
    <name>Non reentrant function 'getnetbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyaddr_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getnetbyaddr' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getnetbyaddr_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getnetbyaddrCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getnetbynameCalled</key>
    <name>Non reentrant function 'getnetbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getnetbyname' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getnetbyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getnetbynameCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getnetentCalled</key>
    <name>Non reentrant function 'getnetent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getnetent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getnetent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getnetentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getnetgrentCalled</key>
    <name>Non reentrant function 'getnetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetgrent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getnetgrent' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getnetgrent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getnetgrentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getprotobynameCalled</key>
    <name>Non reentrant function 'getprotobyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getprotobyname' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getprotobyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getprotobynameCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getprotobynumberCalled</key>
    <name>Non reentrant function 'getprotobynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobynumber_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getprotobynumber' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getprotobynumber_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getprotobynumberCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getprotoentCalled</key>
    <name>Non reentrant function 'getprotoent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotoent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getprotoent' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getprotoent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getprotoentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getpwentCalled</key>
    <name>Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getpwent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getpwent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getpwentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getpwnamCalled</key>
    <name>Non reentrant function 'getpwnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwnam_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getpwnam' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getpwnam_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getpwnamCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getpwuidCalled</key>
    <name>Non reentrant function 'getpwuid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwuid_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getpwuid' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getpwuid_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getpwuidCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getrpcbynameCalled</key>
    <name>Non reentrant function 'getrpcbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getrpcbyname' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getrpcbyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getrpcbynameCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getrpcbynumberCalled</key>
    <name>Non reentrant function 'getrpcbynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbynumber_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getrpcbynumber' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getrpcbynumber_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getrpcbynumberCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getrpcentCalled</key>
    <name>Non reentrant function 'getrpcent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getrpcent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getrpcent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getrpcentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getsCalled</key>
    <name>Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead</name>
    <description>
      <![CDATA[
<p>
The obsolete function 'gets' is called. With 'gets' you'll get a
buffer overrun if the input data exceeds the size of the buffer. It is
recommended to use the functions 'fgets' or 'gets_s' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getsCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getservbynameCalled</key>
    <name>Non reentrant function 'getservbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getservbyname' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getservbyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getservbynameCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getservbyportCalled</key>
    <name>Non reentrant function 'getservbyport' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyport_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getservbyport' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getservbyport_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getservbyportCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getserventCalled</key>
    <name>Non reentrant function 'getservent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getservent' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getservent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getserventCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getspentCalled</key>
    <name>Non reentrant function 'getspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getspent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getspent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getspentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getspnamCalled</key>
    <name>Non reentrant function 'getspnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspnam_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getspnam' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getspnam_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getspnamCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>getwdCalled</key>
    <name>Obsolescent function 'getwd' called. It is recommended to use 'getcwd' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'getwd' called. It is recommended to use 'getcwd'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>getwdCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>indexCalled</key>
    <name>Obsolescent function 'index' called. It is recommended to use 'strchr' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'index' called. It is recommended to use 'strchr'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>indexCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>lstrcatCalled</key>
    <name>Due to security concerns it is not recommended to use this function, see MSDN for details</name>
    <description>
      <![CDATA[
<p>
Due to security concerns it is not recommended to use this function,
see MSDN for details.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>lstrcatCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>makecontextCalled</key>
    <name>Obsolescent function 'makecontext' called. Applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'makecontext' called. Applications are
recommended to be rewritten to use POSIX threads.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>makecontextCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>mktempCalled</key>
    <name>Obsolete function 'mktemp' called. It is recommended to use 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
<p>
The function 'mktemp' is considered to be dangerous due to race
conditions and some implementations generating only up to 26 different
filenames out of each template. This function has been removed in
POSIX.1-2008. Use 'mkstemp' or 'mkdtemp' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>mktempCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pthread_attr_getstackaddrCalled</key>
    <name>Obsolescent function 'pthread_attr_getstackaddr' called. It is recommended to use 'pthread_attr_getstack' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'pthread_attr_getstackaddr' called. It is
recommended to use 'pthread_attr_getstack' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>pthread_attr_getstackaddrCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pthread_attr_setstackaddrCalled</key>
    <name>Obsolescent function 'pthread_attr_setstackaddr' called. It is recommended to use 'pthread_attr_setstack' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'pthread_attr_setstackaddr' called. It is
recommended to use 'pthread_attr_setstack' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>pthread_attr_setstackaddrCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>rand_rCalled</key>
    <name>Obsolescent function 'rand_r' called. It is recommended to use 'rand' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'rand_r' called. It is recommended to use 'rand'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>rand_rCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>readdirCalled</key>
    <name>Non reentrant function 'readdir' called. For threadsafe applications it is recommended to use the reentrant replacement function 'readdir_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'readdir' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'readdir_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>readdirCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>rindexCalled</key>
    <name>Obsolescent function 'rindex' called. It is recommended to use 'strrchr' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'rindex' called. It is recommended to use
'strrchr' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>rindexCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>scalbCalled</key>
    <name>Obsolescent function 'scalb' called. It is recommended to use 'scalbln', 'scalblnf', 'scalbln', 'scalbn', 'scalbnf' or 'scalbnl' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'scalb' called. It is recommended to use
'scalbln', 'scalblnf', 'scalbln', 'scalbn', 'scalbnf' or 'scalbnl'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>scalbCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sgetspentCalled</key>
    <name>Non reentrant function 'sgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'sgetspent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'sgetspent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'sgetspent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>sgetspentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sizeofFunctionCall</key>
    <name>Found function call inside sizeof()</name>
    <description>
      <![CDATA[
<p>
Found function call inside sizeof().
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>sizeofFunctionCall</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>std::asctimeCalled</key>
    <name>Obsolete function 'std::asctime' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'std::asctime' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>std::asctimeCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>std::strtokCalled</key>
    <name>Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'strtok' called. For threadsafe applications it
is recommended to use the reentrant replacement function 'strtok_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>std::strtokCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>strlwrCalled</key>
    <name>Obsolete function 'strlwr' called. It is recommended to use '_strlwr' or '_strlwr_s' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'strlwr' called. It is recommended to use '_strlwr'
or '_strlwr_s' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>strlwrCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>struprCalled</key>
    <name>Obsolete function 'strupr' called. It is recommended to use '_strupr' or '_strupr_s' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'strupr' called. It is recommended to use '_strupr'
or '_strupr_s' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>struprCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>swapcontextCalled</key>
    <name>Obsolescent function 'swapcontext' called. Applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'swapcontext' called. Applications are
recommended to be rewritten to use POSIX threads.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>swapcontextCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>tempnamCalled</key>
    <name>Non reentrant function 'tempnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'tempnam_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'tempnam' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'tempnam_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>tempnamCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>tmpnam_rCalled</key>
    <name>Obsolescent function 'tmpnam_r' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'tmpnam_r' called. It is recommended to use
'tmpfile', 'mkstemp' or 'mkdtemp' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>tmpnam_rCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>ttynameCalled</key>
    <name>Non reentrant function 'ttyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ttyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'ttyname' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'ttyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>ttynameCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>ualarmCalled</key>
    <name>Obsolescent function 'ualarm' called. It is recommended to use 'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime' or 'timer_settime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'ualarm' called. It is recommended to use
'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime' or
'timer_settime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>ualarmCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>usleepCalled</key>
    <name>Obsolescent function 'usleep' called. It is recommended to use 'nanosleep' or 'setitimer' instead</name>
    <description>
      <![CDATA[
<p>
The obsolescent function 'usleep' is called. POSIX.1-2001 declares
usleep() function obsolescent and POSIX.1-2008 removes it. It is
recommended that new applications use the 'nanosleep' or 'setitimer'
function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>usleepCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>utimeCalled</key>
    <name>Obsolescent function 'utime' called. It is recommended to use 'utimensat' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'utime' called. It is recommended to use
'utimensat' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>utimeCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>vforkCalled</key>
    <name>Obsolescent function 'vfork' called. It is recommended to use 'fork' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'vfork' called. It is recommended to use 'fork'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>vforkCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wcswcsCalled</key>
    <name>Obsolescent function 'wcswcs' called. It is recommended to use 'wcsstr' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'wcswcs' called. It is recommended to use
'wcsstr' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wcswcsCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxApp::MacOpenFileCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'wxApp::MacOpenFiles' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'wxApp::MacOpenFiles' method instead in
any new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxApp::MacOpenFileCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxArtProvider::InsertCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'PushBack' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'PushBack' method instead in any new
code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxArtProvider::InsertCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxCalendarCtrl::EnableYearChangeCalled</key>
    <name>This function should be used instead of changing 'wxCAL_NO_YEAR_CHANGE' style bit directly. It allows or disallows the user to change the year interactively. Only in generic 'wxCalendarCtrl'</name>
    <description>
      <![CDATA[
<p>
This function should be used instead of changing
'wxCAL_NO_YEAR_CHANGE' style bit directly. It allows or disallows the
user to change the year interactively. Only in generic
'wxCalendarCtrl'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxCalendarCtrl::EnableYearChangeCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxComboCtrl::GetTextIndentCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'GetMargins()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'GetMargins()' method instead in any
new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxComboCtrl::GetTextIndentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxComboCtrl::HidePopupCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'Dismiss()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'Dismiss()' method instead in any new
code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxComboCtrl::HidePopupCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxComboCtrl::SetTextIndentCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'SetMargins()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'SetMargins()' method instead in any
new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxComboCtrl::SetTextIndentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxComboCtrl::ShowPopupCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'Popup()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'Popup()' method instead in any new
code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxComboCtrl::ShowPopupCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxDataViewCustomRenderer::ActivateCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'wxDataViewCustomRenderer::ActivateCell()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override
'wxDataViewCustomRenderer::ActivateCell()' method instead in any new
code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxDataViewCustomRenderer::ActivateCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxDebugContext::GetLevelCalled</key>
    <name>This function is deprecated and is replaced by 'wxLog' functionality</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and is replaced by 'wxLog' functionality.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxDebugContext::GetLevelCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxDos2UnixFilenameCalled</key>
    <name>This function is deprecated. Construct a 'wxFileName' with 'wxPATH_DOS' and then use 'wxFileName::GetFullPath(wxPATH_UNIX)' instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. Construct a 'wxFileName' with
'wxPATH_DOS' and then use 'wxFileName::GetFullPath(wxPATH_UNIX)'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxDos2UnixFilenameCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxFileNameFromPathCalled</key>
    <name>This function is deprecated. Please use 'wxFileName::SplitPath()' instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. Please use 'wxFileName::SplitPath()'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxFileNameFromPathCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxGetWorkingDirectoryCalled</key>
    <name>Obsolete function 'wxGetWorkingDirectory' called. It is recommended to use 'wxGetCwd' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'wxGetWorkingDirectory' called. It is recommended to
use 'wxGetCwd' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxGetWorkingDirectoryCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxGrid::SetCellAlignmentCalled</key>
    <name>This function is deprecated. Please use 'wxGrid::SetCellAlignment(row, col, horiz, vert)' instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. Please use 'wxGrid::SetCellAlignment(row,
col, horiz, vert)' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxGrid::SetCellAlignmentCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxSizerItem::SetSizerCalled</key>
    <name>This function is deprecated. This function does not free the old sizer which may result in memory leaks, use 'wxSizerItem::AssignSizer' which does free it instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. This function does not free the old sizer
which may result in memory leaks, use 'wxSizerItem::AssignSizer' which
does free it instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxSizerItem::SetSizerCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxSizerItem::SetSpacerCalled</key>
    <name>This function is deprecated. This function does not free the old sizer which may result in memory leaks, use 'wxSizerItem::AssignSpacer' which does free it instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. This function does not free the old sizer
which may result in memory leaks, use 'wxSizerItem::AssignSpacer'
which does free it instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxSizerItem::SetSpacerCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxSizerItem::SetWindowCalled</key>
    <name>This function is deprecated</name>
    <description>
      <![CDATA[
<p>
This function is deprecated.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxSizerItem::SetWindowCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxString::IsNullCalled</key>
    <name>This is the same as 'wxString::IsEmpty' and is kept for wxWidgets 1.xx compatibility. You should not use it in new code</name>
    <description>
      <![CDATA[
<p>
This is the same as 'wxString::IsEmpty' and is kept for wxWidgets 1.xx
compatibility. You should not use it in new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxString::IsNullCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxString::LengthCalled</key>
    <name>This is the same as 'wxString::Len' and is kept for wxWidgets 1.xx compatibility. You should not use it in new code</name>
    <description>
      <![CDATA[
<p>
This is the same as 'wxString::Len' and is kept for wxWidgets 1.xx
compatibility. You should not use it in new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxString::LengthCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxString::LowerCaseCalled</key>
    <name>This is the same as 'wxString::MakeLower' and is kept for wxWidgets 1.xx compatibility. You should not use it in new code</name>
    <description>
      <![CDATA[
<p>
This is the same as 'wxString::MakeLower' and is kept for wxWidgets
1.xx compatibility. You should not use it in new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxString::LowerCaseCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>asctimeCalled</key>
    <name>Obsolete function 'asctime' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'asctime' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>asctimeCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>gethostbynameCalled</key>
    <name>Obsolescent function 'gethostbyname' called. It is recommended to use 'getaddrinfo' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'gethostbyname' called. It is recommended to use
'getaddrinfo' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>gethostbynameCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>localtimeCalled</key>
    <name>Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'localtime' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'localtime_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>localtimeCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>strtokCalled</key>
    <name>Non reentrant function 'strtok' called</name>
    <description>
      <![CDATA[<p>
Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'.
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Functions</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>strtokCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>tmpnamCalled</key>
    <name>Obsolescent function 'tmpnam' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'tmpnam' called. It is recommended to use
'tmpfile', 'mkstemp' or 'mkdtemp' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>tmpnamCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unhandledExceptionSpecification</key>
    <name>Unhandled exception specification</name>
    <description>
      <![CDATA[
<p>
Unhandled exception specification when calling function foo(). Either
use a try/catch around the function call, or add a exception
specification for funcname() also.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/703.html" target="_blank">CWE-703: Improper Check or Handling of Exceptional Conditions</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>unhandledExceptionSpecification</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>purgedConfiguration</key>
    <name>The configuration 'define' was not checked because its code equals another one</name>
    <description>
      <![CDATA[
The configuration 'define' was not checked because its code equals another one.
    ]]>
    </description>
    <internalKey>purgedConfiguration</internalKey>
    <severity>INFO</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>internalError</key>
    <name>Internal Cppcheck tool error</name>
    <description>
      <![CDATA[<p>
Internal Cppcheck tool error. Create an issue on the Cppcheck issue tracker.
</p><h2>References</h2>
<p><a href="http://trac.cppcheck.net/" target="_blank">Cppcheck development</a></p>
]]>
    </description>
    <internalKey>internalError</internalKey>
    <severity>INFO</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>QString::vsprintfCalled</key>
    <name>Obsolete function 'QString::vsprintf' called. It is recommended to use 'QString::vasprintf', 'QString::arg' or 'QTextStream' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'QString::vsprintf' called. It is recommended to use
'QString::vasprintf', 'QString::arg' or 'QTextStream' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>QString::vsprintfCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>asctime_sCalled</key>
    <name>Obsolete function 'asctime_s' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'asctime_s' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>asctime_sCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>duplicateValueTernary</key>
    <name>Same value in both branches of ternary operator</name>
    <description>
      <![CDATA[
<p>
Finding the same value in both branches of ternary operator is
suspicious as the same code is executed regardless of the condition.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>duplicateValueTernary</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>identicalInnerCondition</key>
    <name>Identical inner 'if' condition</name>
    <description>
      <![CDATA[
<p>
Identical inner 'if' condition is always true/false (outer condition is equal to the
inner condition).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>identicalInnerCondition</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>missingOverride</key>
    <name>Missing override</name>
    <description>
      <![CDATA[
The function overrides a function in a base class but is not marked with a 'override' specifier.
    ]]>
    </description>
    <internalKey>missingOverride</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>noDestructor</key>
    <name>Missing destructor</name>
    <description>
      <![CDATA[
<p>
Class 'class' does not have a destructor which is recommended since it
has dynamic memory/resource allocation(s).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>noDestructor</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>noOperatorEq</key>
    <name>Missing assignment operator</name>
    <description>
      <![CDATA[
<p>
Class 'class' does not have a operator= which is recommended since it
has dynamic memory/resource allocation(s).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>noOperatorEq</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>oppositeExpression</key>
    <name>Opposite expression on both sides of logical operator</name>
    <description>
      <![CDATA[
<p>
Finding the opposite expression on both sides of an operator is
suspicious and might indicate a cut and paste or logic error. Please
examine this code carefully to determine if it is correct.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>oppositeExpression</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>pureVirtualCall</key>
    <name>Call of pure virtual function in constructor</name>
    <description>
      <![CDATA[
Call of pure virtual function in constructor. The call will fail during runtime.
    ]]>
    </description>
    <tag>bug</tag>
    <internalKey>pureVirtualCall</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>qInstallMsgHandlerCalled</key>
    <name>Obsolete function 'qInstallMsgHandler' called. It is recommended to use 'qInstallMessageHandler' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'qInstallMsgHandler' called. It is recommended to
use 'qInstallMessageHandler' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>qInstallMsgHandlerCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>qrandCalled</key>
    <name>Obsolete function 'qrand' called. It is recommended to use 'QRandomGenerator' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'qrand' called. It is recommended to use
'QRandomGenerator' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>qrandCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>qsrandCalled</key>
    <name>Obsolete function 'qsrand' called. It is recommended to use 'QRandomGenerator' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'qsrand' called. It is recommended to use
'QRandomGenerator' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>qsrandCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>std::asctime_sCalled</key>
    <name>Obsolete function 'std::asctime_s' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'std::asctime_s' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>std::asctime_sCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>umaskCalled</key>
    <name>Obsolete function 'umask' called. It is recommended to use '_umask' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'umask' called. It is recommended to use '_umask'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <internalKey>umaskCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>virtualCallInConstructor</key>
    <name>Virtual function is called from constructor</name>
    <description>
      <![CDATA[
Call of pure virtual function in constructor. Dynamic binding is not used.
    ]]>
    </description>
    <tag>bug</tag>
    <internalKey>virtualCallInConstructor</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>QString::sprintfCalled</key>
    <name>Obsolete function 'QString::sprintf' called. It is recommended to use 'QString::asprintf', 'QString::arg' or 'QTextStream' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'QString::sprintf' called. It is recommended to use
'QString::asprintf', 'QString::arg' or 'QTextStream' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>QString::sprintfCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>containerOutOfBounds</key>
    <name>Out of bounds access of item in container 'var'</name>
    <description>
      <![CDATA[
<p>
Out of bounds access of item in container 'var'
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>containerOutOfBounds</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>incorrectCharBooleanError</key>
    <name>Conversion of char literal 'x' to bool always evaluates to true</name>
    <description>
      <![CDATA[
<p>
Conversion of char literal 'x' to bool always evaluates to true.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>incorrectCharBooleanError</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>mismatchingContainerExpression</key>
    <name>Iterators to containers from different expressions 'v1' and 'v2' are used together</name>
    <description>
      <![CDATA[
<p>
Iterators to containers from different expressions 'v1' and 'v2' are
used together.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>mismatchingContainerExpression</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>sameIteratorExpression</key>
    <name>Same iterators expression are used for algorithm</name>
    <description>
      <![CDATA[
<p>
Same iterators expression are used for algorithm.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>sameIteratorExpression</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>useStlAlgorithm</key>
    <name>Consider using  algorithm instead of a raw loop</name>
    <description>
      <![CDATA[
<p>
Consider using  algorithm instead of a raw loop.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>useStlAlgorithm</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxString::StripCalled</key>
    <name>This is the same as wxString::Trim() except that it doesn't change this string. This is a wxWidgets 1.xx compatibility function; you should not use it in new code</name>
    <description>
      <![CDATA[
<p>
This is the same as wxString::Trim() except that it doesn't change
this string. This is a wxWidgets 1.xx compatibility function; you
should not use it in new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxString::StripCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>danglingLifetime</key>
    <name>Non-local variable will use object</name>
    <description>
      <![CDATA[
<p>
Non-local variable 'x' will use object.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>danglingLifetime</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>duplicateAssignExpression</key>
    <name>Same expression used in consecutive assignments</name>
    <description>
      <![CDATA[
<p>
Finding variables 'x' and 'x' that are assigned the same expression is
suspicious and might indicate a cut and paste or logic error. Please
examine this code carefully to determine if it is correct.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>duplicateAssignExpression</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidFunctionArgStr</key>
    <name>Invalid function argument. A nul-terminated string is required</name>
    <description>
      <![CDATA[
<p>
Invalid function argument. A nul-terminated string is
required.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>invalidFunctionArgStr</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidLifetime</key>
    <name>Using object that is out of scope</name>
    <description>
      <![CDATA[
<p>
Using object that is out of scope.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>invalidLifetime</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>iterators1</key>
    <name>Same iterator is used with different containers</name>
    <description>
      <![CDATA[
<p>
Same iterator is used with different containers 'container1' and
'container2'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>iterators1</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>iterators3</key>
    <name>Same iterator is used with containers 'container' that are defined in different scopes</name>
    <description>
      <![CDATA[
<p>
Same iterator is used with containers 'container' that are defined in
different scopes.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>iterators3</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>iteratorsCmp1</key>
    <name>Comparison of iterators from different containers</name>
    <description>
      <![CDATA[
<p>
Comparison of iterators from containers 'container1' and 'container2'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>iteratorsCmp1</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>iteratorsCmp2</key>
    <name>Comparison of iterators from containers 'container' that are defined in different scopes</name>
    <description>
      <![CDATA[
<p>
Comparison of iterators from containers 'container' that are defined
in different scopes.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>iteratorsCmp2</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>returnDanglingLifetime</key>
    <name>Returning object that will be invalid when returning</name>
    <description>
      <![CDATA[
<p>
Returning object that will be invalid when returning.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>returnDanglingLifetime</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>returnNonBoolInBooleanFunction</key>
    <name>Non-boolean value returned from function returning bool</name>
    <description>
      <![CDATA[
Non-boolean value returned from function returning bool
]]>
    </description>
    <internalKey>returnNonBoolInBooleanFunction</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>shadowFunction</key>
    <name>Local variable shadows outer function</name>
    <description>
      <![CDATA[
<p>
Local variable shadows outer function
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>shadowFunction</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>shadowVar</key>
    <name>Local variable shadows outer variable</name>
    <description>
      <![CDATA[
<p>
Local variable shadows outer variable
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>shadowVar</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>constArgument</key>
    <name>Const argument</name>
    <description>
      <![CDATA[
<p>
Argument 'x' to function f is always 0
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>constArgument</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>danglingReference</key>
    <name>Dangling reference</name>
    <description>
      <![CDATA[
<p>
Non-local reference variable 'x' to local variable 'y'
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>danglingReference</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>duplicateCondition</key>
    <name>Duplicate condition</name>
    <description>
      <![CDATA[
<p>
The if condition is the same as the previous if condition
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>duplicateCondition</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidScanfFormatWidth_smaller</key>
    <name>Wrong width for scanf parameter (too small)</name>
    <description>
      <![CDATA[
Width 'w0' given in format string is smaller than destination buffer '[w1]'.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>invalidScanfFormatWidth_smaller</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>iterators2</key>
    <name>Same iterator is used with different containers</name>
    <description>
      <![CDATA[
<p>
Same iterator is used with different containers 'container0' and
'container1'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>iterators2</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>nullPointerArithmeticRedundantCheck</key>
    <name>Redundant condition or NULL pointer arithmetic</name>
    <description>
      <![CDATA[
<p>
Either the condition is redundant or there is pointer arithmetic with
NULL pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>nullPointerArithmeticRedundantCheck</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>wxBitmap::SetDepthCalled</key>
    <name>This function is deprecated since version 3.1.2, dimensions and depth can only be set at construction time</name>
    <description>
      <![CDATA[
<p>
This function is deprecated since version 3.1.2, dimensions and depth
can only be set at construction time.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>wxBitmap::SetDepthCalled</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>comparePointers</key>
    <name>Comparing pointers that point to different objects</name>
    <description>
      <![CDATA[
<p>
Comparing pointers that point to different objects
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>comparePointers</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>duplicateConditionalAssign</key>
    <name>Duplicate expression for the condition and assignment</name>
    <description>
      <![CDATA[
<p>
Duplicate expression for the condition and assignment.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>duplicateConditionalAssign</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>negativeContainerIndex</key>
    <name>Array index -1 is out of bounds</name>
    <description>
      <![CDATA[
<p>
Array index -1 is out of bounds.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/786.html" target="_blank">CWE-786: Access of Memory Location Before Start of Buffer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>negativeContainerIndex</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>objectIndex</key>
    <name>The address of local variable '' is accessed at non-zero index</name>
    <description>
      <![CDATA[
<p>
The address of local variable '' is accessed at non-zero index.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>objectIndex</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>stlFindInsert</key>
    <name>Searching before insertion is not necessary</name>
    <description>
      <![CDATA[
<p>
Searching before insertion is not necessary.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>stlFindInsert</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>uninitMemberVarPrivate</key>
    <name>Member variable 'classname::varnamepriv' is not initialized in the constructor</name>
    <description>
      <![CDATA[
<p>
Member variable 'classname::varnamepriv' is not initialized in the
constructor.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>uninitMemberVarPrivate</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <!-- ########### New in cppcheck 1.90 ########### -->
  <rule>
    <key>constVariable</key>
    <name>Variable 'x' can be declared with const</name>
    <description>
      <![CDATA[
<p>
Variable 'x' can be declared with const
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>constVariable</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>danglingTemporaryLifetime</key>
    <name>Using object to temporary</name>
    <description>
      <![CDATA[
<p>
Using object to temporary.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>danglingTemporaryLifetime</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>invalidContainer</key>
    <name>Using object that may be invalid</name>
    <description>
      <![CDATA[
<p>
Using object that may be invalid.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <tag>bug</tag>
    <internalKey>invalidContainer</internalKey>
    <severity>MAJOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>redundantInitialization</key>
    <name>Redundant initialization for 'var'. The initialized value is overwritten before it is read</name>
    <description>
      <![CDATA[
<p>
Redundant initialization for 'var'. The initialized value is
overwritten before it is read.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>redundantInitialization</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>shadowArgument</key>
    <name>Local variable 'argument' shadows outer argument</name>
    <description>
      <![CDATA[
<p>
Local variable 'argument' shadows outer argument
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>shadowArgument</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>shadowVariable</key>
    <name>Local variable 'variable' shadows outer variable</name>
    <description>
      <![CDATA[
<p>
Local variable 'variable' shadows outer variable
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <internalKey>shadowVariable</internalKey>
    <severity>MINOR</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>unsafeClassRefMember</key>
    <name>Unsafe class: The const reference member 'UnsafeClass::var' is initialized by a const reference constructor argument. You need to be careful about lifetime issues</name>
    <description>
      <![CDATA[
Unsafe class checking: The const reference member 'UnsafeClass::var' is initialized by a const reference constructor argument. You need to be careful about lifetime issues. If you pass a local variable or temporary value in this constructor argument, be extra careful. If the argument is always some global object that is never destroyed then this is safe usage. However it would be defensive to make the member 'UnsafeClass::var' a non-reference variable or a smart pointer.
]]>
    </description>
    <tag>bug</tag>
    <internalKey>unsafeClassRefMember</internalKey>
    <severity>MINOR</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
</rules>
